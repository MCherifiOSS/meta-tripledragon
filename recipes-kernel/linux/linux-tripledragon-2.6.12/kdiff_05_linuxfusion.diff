diff -Xxfiles -rNBwdu linux-2.6.12.orig/include/linux/fusion.h linux-2.6.12/include/linux/fusion.h
--- linux-2.6.12.orig/include/linux/fusion.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/include/linux/fusion.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,202 @@
+#ifndef __LINUX__FUSION_H__
+#define __LINUX__FUSION_H__
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+/*
+ * Sending
+ */
+typedef struct {
+     int         fusion_id;      /* recipient */
+
+     int         msg_id;         /* optional message identifier */
+     int         msg_size;       /* message size, must be greater than zero */
+     const void *msg_data;       /* message data, must not be NULL */
+} FusionSendMessage;
+
+/*
+ * Receiving
+ */
+typedef enum {
+     FMT_SEND,
+     FMT_CALL,                   /* msg_id is the call id */
+     FMT_REACTOR                 /* msg_id is the reactor id */
+} FusionMessageType;
+
+typedef struct {
+     FusionMessageType msg_type;
+
+     int               msg_id;
+     int               msg_size;
+
+     /* message data follows */
+} FusionReadMessage;
+
+/*
+ * Dispatching
+ */
+typedef struct {
+     int         reactor_id;
+     int         self;
+
+     int         msg_size;       /* message size, must be greater than zero */
+     const void *msg_data;       /* message data, must not be NULL */
+} FusionReactorDispatch;
+
+/*
+ * Calling (synchronous RPC)
+ */
+typedef struct {
+     int                call_id;   /* new call id returned */
+
+     void              *handler;   /* function pointer of handler to install */
+     void              *ctx;       /* optional handler context */
+} FusionCallNew;
+
+typedef struct {
+     int   ret_val;              /* return value of the call */
+
+     int   call_id;              /* id of the requested call,
+                                    each call has a fixed owner */
+
+     int   call_arg;             /* optional int argument */
+     void *call_ptr;             /* optional pointer argument (shared memory) */
+} FusionCallExecute;
+
+typedef struct {
+     int   call_id;              /* id of currently executing call */
+
+     int   val;                  /* value to return */
+} FusionCallReturn;
+
+typedef struct {
+     void              *handler;   /* function pointer of handler to call */
+     void              *ctx;       /* optional handler context */
+
+     int                caller;    /* fusion id of the caller
+                                      or zero if the call comes from Fusion */
+     int                call_arg;  /* optional call parameter */
+     void              *call_ptr;  /* optional call parameter */
+} FusionCallMessage;
+
+/*
+ * Watching a reference
+ *
+ * This information is needed to have a specific call being executed if the
+ * reference count reaches zero. Currently one watch per reference is allowed.
+ *
+ * The call is made by Fusion and therefor has a caller id of zero.
+ *
+ */
+typedef struct {
+     int                id;        /* id of the reference to watch */
+
+     int                call_id;   /* id of the call to execute */
+     int                call_arg;  /* optional call parameter, e.g. the id of a
+                                      user space resource associated with that
+                                      reference */
+} FusionRefWatch;
+
+/*
+ * Inheriting local count from other reference
+ */
+typedef struct {
+     int                id;        /* own reference id */
+     int                from;      /* id of the reference to inherit from */
+} FusionRefInherit;
+
+/*
+ * Killing other fusionees (experimental)
+ */
+typedef struct {
+     int fusion_id;    /* fusionee to kill, zero means all but ourself */
+     int signal;       /* signal to be delivered, e.g. SIGTERM */
+     int timeout_ms;   /* -1 means no timeout, 0 means infinite, otherwise the
+                          max. time to wait until the fusionee(s) terminated */
+} FusionKill;
+
+
+typedef enum {
+     FT_LOUNGE,
+     FT_MESSAGING,
+     FT_CALL,
+     FT_REF,
+     FT_SKIRMISH,
+     FT_PROPERTY,
+     FT_REACTOR
+} FusionType;
+
+
+/*
+ * Set attributes like 'name' for an entry of the specified type.
+ */
+#define FUSION_ENTRY_INFO_NAME_LENGTH   24
+
+typedef struct {
+     FusionType type;
+     int        id;
+
+     char       name[FUSION_ENTRY_INFO_NAME_LENGTH];
+} FusionEntryInfo;
+
+
+typedef struct {
+     struct {
+          int major;
+          int minor;
+     } api;
+
+     int fusion_id;
+} FusionEnter;
+
+#define FUSION_API_MAJOR   1  /* Increased if backward compatibility is dropped. */
+#define FUSION_API_MINOR   1  /* Increased if new features are added. */
+
+
+#define FUSION_ENTER               _IOR(FT_LOUNGE,    0x00, FusionEnter)
+#define FUSION_KILL                _IOW(FT_LOUNGE,    0x01, FusionKill)
+
+#define FUSION_ENTRY_SET_INFO      _IOW(FT_LOUNGE,    0x02, FusionEntryInfo)
+#define FUSION_ENTRY_GET_INFO      _IOW(FT_LOUNGE,    0x03, FusionEntryInfo)
+
+#define FUSION_SEND_MESSAGE        _IOW(FT_MESSAGING, 0x00, FusionSendMessage)
+
+#define FUSION_CALL_NEW            _IOW(FT_CALL,      0x00, FusionCallNew)
+#define FUSION_CALL_EXECUTE        _IOW(FT_CALL,      0x01, FusionCallExecute)
+#define FUSION_CALL_RETURN         _IOW(FT_CALL,      0x02, FusionCallReturn)
+#define FUSION_CALL_DESTROY        _IOW(FT_CALL,      0x03, int)
+
+#define FUSION_REF_NEW             _IOW(FT_REF,       0x00, int)
+#define FUSION_REF_UP              _IOW(FT_REF,       0x01, int)
+#define FUSION_REF_UP_GLOBAL       _IOW(FT_REF,       0x02, int)
+#define FUSION_REF_DOWN            _IOW(FT_REF,       0x03, int)
+#define FUSION_REF_DOWN_GLOBAL     _IOW(FT_REF,       0x04, int)
+#define FUSION_REF_ZERO_LOCK       _IOW(FT_REF,       0x05, int)
+#define FUSION_REF_ZERO_TRYLOCK    _IOW(FT_REF,       0x06, int)
+#define FUSION_REF_UNLOCK          _IOW(FT_REF,       0x07, int)
+#define FUSION_REF_STAT            _IOW(FT_REF,       0x08, int)
+#define FUSION_REF_WATCH           _IOW(FT_REF,       0x09, FusionRefWatch)
+#define FUSION_REF_INHERIT         _IOW(FT_REF,       0x0A, FusionRefInherit)
+#define FUSION_REF_DESTROY         _IOW(FT_REF,       0x0B, int)
+
+#define FUSION_SKIRMISH_NEW        _IOW(FT_SKIRMISH,  0x00, int)
+#define FUSION_SKIRMISH_PREVAIL    _IOW(FT_SKIRMISH,  0x01, int)
+#define FUSION_SKIRMISH_SWOOP      _IOW(FT_SKIRMISH,  0x02, int)
+#define FUSION_SKIRMISH_DISMISS    _IOW(FT_SKIRMISH,  0x03, int)
+#define FUSION_SKIRMISH_DESTROY    _IOW(FT_SKIRMISH,  0x04, int)
+
+#define FUSION_PROPERTY_NEW        _IOW(FT_PROPERTY,  0x00, int)
+#define FUSION_PROPERTY_LEASE      _IOW(FT_PROPERTY,  0x01, int)
+#define FUSION_PROPERTY_PURCHASE   _IOW(FT_PROPERTY,  0x02, int)
+#define FUSION_PROPERTY_CEDE       _IOW(FT_PROPERTY,  0x03, int)
+#define FUSION_PROPERTY_HOLDUP     _IOW(FT_PROPERTY,  0x04, int)
+#define FUSION_PROPERTY_DESTROY    _IOW(FT_PROPERTY,  0x05, int)
+
+#define FUSION_REACTOR_NEW         _IOW(FT_REACTOR,   0x00, int)
+#define FUSION_REACTOR_ATTACH      _IOW(FT_REACTOR,   0x01, int)
+#define FUSION_REACTOR_DETACH      _IOW(FT_REACTOR,   0x02, int)
+#define FUSION_REACTOR_DISPATCH    _IOW(FT_REACTOR,   0x03, FusionReactorDispatch)
+#define FUSION_REACTOR_DESTROY     _IOW(FT_REACTOR,   0x04, int)
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/Kconfig linux-2.6.12/drivers/char/Kconfig
--- linux-2.6.12.orig/drivers/char/Kconfig	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/Kconfig	2005-06-26 00:17:16.000000000 +0200
@@ -998,5 +998,10 @@

 source "drivers/char/tpm/Kconfig"

-endmenu
+config FUSION_DEVICE
+	tristate "Fusion Kernel Device (for DirectFB)"
+	help
+	  The Fusion Kernel Device is needed to use DirectFB's multi
+	  application core.

+endmenu
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/Makefile linux-2.6.12/drivers/char/Makefile
--- linux-2.6.12.orig/drivers/char/Makefile	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/Makefile	2005-06-26 00:17:16.000000000 +0200
@@ -89,6 +89,8 @@
 obj-$(CONFIG_PCMCIA) += pcmcia/
 obj-$(CONFIG_IPMI_HANDLER) += ipmi/

+obj-$(CONFIG_FUSION_DEVICE) += fusion/
+
 obj-$(CONFIG_HANGCHECK_TIMER) += hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM) += tpm/
 # Files generated that shall be removed upon make clean
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/.cvsignore linux-2.6.12/drivers/char/_fusion_/.cvsignore
--- linux-2.6.12.orig/drivers/char/_fusion_/.cvsignore	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/.cvsignore	2003-12-15 19:11:48.000000000 +0100
@@ -0,0 +1,5 @@
+*.o.flags
+*.cmd
+Makefile
+fusion.ko
+fusion.mod.c
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/Makefile linux-2.6.12/drivers/char/_fusion_/Makefile
--- linux-2.6.12.orig/drivers/char/_fusion_/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/Makefile	2005-06-24 19:25:05.000000000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FUSION_DEVICE) += fusion.o
+
+fusion-y := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.4 linux-2.6.12/drivers/char/_fusion_/Makefile-2.4
--- linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.4	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/Makefile-2.4	2005-06-25 14:56:25.000000000 +0200
@@ -0,0 +1,6 @@
+O_TARGET := fusion.o
+
+obj-y   := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
+obj-$(CONFIG_FUSION_DEVICE)   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.6 linux-2.6.12/drivers/char/_fusion_/Makefile-2.6
--- linux-2.6.12.orig/drivers/char/_fusion_/Makefile-2.6	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/Makefile-2.6	2005-06-25 14:56:11.000000000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FUSION_DEVICE) += fusion.o
+
+fusion-y := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/call.c linux-2.6.12/drivers/char/_fusion_/call.c
--- linux-2.6.12.orig/drivers/char/_fusion_/call.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/call.c	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,468 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "call.h"
+
+typedef struct {
+     FusionLink        link;
+
+     int               caller;
+
+     int               ret_val;
+
+     bool              executed;
+
+     wait_queue_head_t wait;
+} FusionCallExecution;
+
+typedef struct {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;        /* call id */
+
+     int                pid;       /* owner pid */
+     int                fusion_id; /* owner fusion id */
+
+     void              *handler;
+     void              *ctx;
+
+     FusionLink          *executions;      /* prepending! */
+     FusionLink          *last;            /* points to the last item of executions */
+
+     int                count;    /* number of calls ever made */
+} FusionCall;
+
+/******************************************************************************/
+
+static int  lookup_call (FusionDev *dev, int id, FusionCall **ret_call);
+static int  lock_call   (FusionDev *dev, int id, FusionCall **ret_call);
+static void unlock_call (FusionCall *call);
+
+static FusionCallExecution *add_execution       (FusionCall          *call,
+                                                 int                  fusion_id,
+                                                 FusionCallExecute   *execute);
+static void                 remove_execution    (FusionCall          *call,
+                                                 FusionCallExecution *execution);
+static void                 free_all_executions (FusionCall          *call);
+
+/******************************************************************************/
+
+static int
+fusion_call_read_proc (char *buf, char **start, off_t offset,
+                       int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          bool        idle = true;
+          FusionCall *call = (FusionCall*) l;
+
+          if (call->executions)
+               idle = ((FusionCallExecution*) call->executions)->executed;
+
+          written += sprintf(buf+written,
+                             "(%5d) 0x%08x (%d calls) %s\n",
+                             call->pid, call->id, call->count,
+                             idle ? "idle" : "executing");
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->call.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_call_init (FusionDev *dev)
+{
+     create_proc_read_entry("calls", 0, dev->proc_dir,
+                            fusion_call_read_proc, dev);
+
+     init_MUTEX(&dev->call.lock);
+
+     return 0;
+}
+
+void
+fusion_call_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     remove_proc_entry ("calls", dev->proc_dir);
+
+     l = dev->call.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          free_all_executions (call);
+
+          kfree (call);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_call_new (FusionDev *dev, int fusion_id, FusionCallNew *call_new)
+{
+     FusionCall *call;
+
+     call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
+     if (!call)
+          return -ENOMEM;
+
+     memset (call, 0, sizeof(FusionCall));
+
+     if (down_interruptible (&dev->call.lock)) {
+          kfree (call);
+          return -EINTR;
+     }
+
+     call->id        = dev->call.ids++;
+     call->pid       = current->pid;
+     call->fusion_id = fusion_id;
+     call->handler   = call_new->handler;
+     call->ctx       = call_new->ctx;
+
+     init_MUTEX (&call->lock);
+
+     fusion_list_prepend (&dev->call.list, &call->link);
+
+     up (&dev->call.lock);
+
+     call_new->call_id = call->id;
+
+     return 0;
+}
+
+int
+fusion_call_execute (FusionDev *dev, int fusion_id, FusionCallExecute *execute)
+{
+     int                  ret;
+     FusionCall          *call;
+     FusionCallExecution *execution;
+     FusionCallMessage    message;
+
+     ret = lock_call (dev, execute->call_id, &call);
+     if (ret)
+          return ret;
+
+     execution = add_execution (call, fusion_id, execute);
+     if (!execution) {
+          unlock_call (call);
+          return -ENOMEM;
+     }
+
+     /* Send call message. */
+     message.handler  = call->handler;
+     message.ctx      = call->ctx;
+
+     message.caller   = fusion_id;
+
+     message.call_arg = execute->call_arg;
+     message.call_ptr = execute->call_ptr;
+
+     ret = fusionee_send_message (dev, fusion_id, call->fusion_id, FMT_CALL,
+                                  call->id, sizeof(message), &message);
+     if (ret) {
+          remove_execution (call, execution);
+          kfree (execution);
+          unlock_call (call);
+          return ret;
+     }
+
+     call->count++;
+
+     if (fusion_id) {
+          /* TODO: implement timeout */
+          fusion_sleep_on (&execution->wait, &call->lock, 0);
+
+          ret = lock_call (dev, execute->call_id, &call);
+          if (ret)
+               return ret == -EINVAL ? -EIDRM : ret;
+
+          if (signal_pending(current)) {
+               execution->caller = 0;
+               unlock_call (call);
+               return -EINTR;
+          }
+
+          execute->ret_val = execution->ret_val;
+
+          remove_execution (call, execution);
+
+          kfree (execution);
+     }
+
+     unlock_call (call);
+
+     return 0;
+}
+
+int
+fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
+{
+     int         ret;
+     FusionLink *l;
+     FusionCall *call;
+
+     ret = lock_call (dev, call_ret->call_id, &call);
+     if (ret)
+          return ret;
+
+     l = call->last;
+     while (l) {
+          FusionCallExecution *execution = (FusionCallExecution*) l;
+
+          if (execution->executed) {
+               l = l->prev;
+               continue;
+          }
+
+          if (execution->caller) {
+               execution->ret_val  = call_ret->val;
+               execution->executed = true;
+
+               wake_up_interruptible_all (&execution->wait);
+          }
+          else {
+               remove_execution (call, execution);
+
+               kfree (execution);
+          }
+
+          unlock_call (call);
+
+          return 0;
+     }
+
+     unlock_call (call);
+
+     return -EIO;
+}
+
+int
+fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, call_id, &call);
+     if (ret)
+          return ret;
+
+     if (call->fusion_id != fusion_id) {
+          up (&dev->call.lock);
+          return -EIO;
+     }
+
+     if (down_interruptible (&call->lock)) {
+          up (&dev->call.lock);
+          return -EINTR;
+     }
+
+     fusion_list_remove (&dev->call.list, &call->link);
+
+     free_all_executions (call);
+
+     up (&dev->call.lock);
+
+     up (&call->lock);
+
+     kfree (call);
+
+     return 0;
+}
+
+void
+fusion_call_destroy_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     l = dev->call.list;
+
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          down (&call->lock);
+
+          if (call->fusion_id == fusion_id) {
+               free_all_executions (call);
+
+               fusion_list_remove (&dev->call.list, &call->link);
+
+               up (&call->lock);
+
+               kfree (call);
+          }
+          else
+               up (&call->lock);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          FusionCall *call = (FusionCall *) l;
+
+          if (call->id == id) {
+               *ret_call = call;
+               return 0;
+          }
+     }
+
+     up (&dev->call.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, id, &call);
+     if (ret)
+          return ret;
+
+     if (call) {
+          fusion_list_move_to_front (&dev->call.list, &call->link);
+
+          if (down_interruptible (&call->lock)) {
+               up (&dev->call.lock);
+               return -EINTR;
+          }
+
+          up (&dev->call.lock);
+     }
+
+     *ret_call = call;
+
+     return 0;
+}
+
+static void
+unlock_call (FusionCall *call)
+{
+     up (&call->lock);
+}
+
+static FusionCallExecution *
+add_execution (FusionCall        *call,
+               int                fusion_id,
+               FusionCallExecute *execute)
+{
+     FusionCallExecution *execution;
+
+     /* Allocate execution. */
+     execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
+     if (!execution)
+          return NULL;
+
+     /* Initialize execution. */
+     memset (execution, 0, sizeof(FusionCallExecution));
+
+     execution->caller = fusion_id;
+
+     init_waitqueue_head (&execution->wait);
+
+     /* Add execution. */
+     fusion_list_prepend (&call->executions, &execution->link);
+
+     if (!call->last)
+          call->last = &execution->link;
+
+     return execution;
+}
+
+static void
+remove_execution (FusionCall          *call,
+                  FusionCallExecution *execution)
+{
+     if (call->last == &execution->link)
+          call->last = execution->link.prev;
+
+     fusion_list_remove (&call->executions, &execution->link);
+}
+
+static void
+free_all_executions (FusionCall *call)
+{
+     while (call->last) {
+          FusionCallExecution *execution = (FusionCallExecution *) call->last;
+
+          remove_execution (call, execution);
+
+          wake_up_interruptible_all (&execution->wait);
+
+          kfree (execution);
+     }
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/call.h linux-2.6.12/drivers/char/_fusion_/call.h
--- linux-2.6.12.orig/drivers/char/_fusion_/call.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/call.h	2003-07-10 01:31:28.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__CALL_H__
+#define __FUSION__CALL_H__
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+
+/* module init/cleanup */
+
+int  fusion_call_init   (FusionDev *dev);
+void fusion_call_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_call_new     (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallNew     *call);
+
+int fusion_call_execute (FusionDev         *dev,
+                         int                fusion_id, /* zero if call is
+                                                          from Fusion */
+                         FusionCallExecute *execute);
+
+int fusion_call_return  (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallReturn  *call_ret);
+
+int fusion_call_destroy (FusionDev         *dev,
+                         int                fusion_id,
+                         int                call_id);
+
+
+/* internal functions */
+
+void fusion_call_destroy_all (FusionDev *dev,
+                              int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/entries.c linux-2.6.12/drivers/char/_fusion_/entries.c
--- linux-2.6.12.orig/drivers/char/_fusion_/entries.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/entries.c	2004-12-12 15:09:40.000000000 +0100
@@ -0,0 +1,417 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/version.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "entries.h"
+
+
+void
+fusion_entries_init( FusionEntries    *entries,
+                     FusionEntryClass *class,
+                     void             *ctx )
+{
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( class != NULL );
+     FUSION_ASSERT( class->object_size >= sizeof(FusionEntry) );
+
+     memset( entries, 0, sizeof(FusionEntries) );
+
+     entries->class = class;
+     entries->ctx   = ctx;
+
+     init_MUTEX( &entries->lock );
+}
+
+void
+fusion_entries_deinit( FusionEntries *entries )
+{
+     FusionLink       *tmp;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     down( &entries->lock );
+
+     fusion_list_foreach_safe (entry, tmp, entries->list) {
+          if (class->Destroy)
+               class->Destroy( entry, entries->ctx );
+
+          kfree( entry );
+     }
+
+     up( &entries->lock );
+}
+
+int
+fusion_entries_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+     FusionEntries    *entries = private;
+     int               written = 0;
+     struct timeval    now;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     if (!class->Print)
+          return -ENOTSUPP;
+
+     if (down_interruptible (&entries->lock))
+          return -EINTR;
+
+     do_gettimeofday( &now );
+
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->last_lock.tv_sec) {
+               int diff = ((now.tv_sec  - entry->last_lock.tv_sec) * 1000 +
+                           (now.tv_usec - entry->last_lock.tv_usec) / 1000);
+
+               if (diff < 1000) {
+                    written += sprintf( buf + written, "%3d  ms  ", diff );
+               }
+               else if (diff < 1000000) {
+                    written += sprintf( buf + written, "%3d.%d s  ",
+                                        diff / 1000, (diff % 1000) / 100 );
+               }
+               else {
+                    diff = ( now.tv_sec  - entry->last_lock.tv_sec +
+                            (now.tv_usec - entry->last_lock.tv_usec) / 1000000);
+
+                    written += sprintf( buf + written, "%3d.%d h  ",
+                                        diff / 3600, (diff % 3600) / 360 );
+               }
+          }
+          else
+               written += sprintf( buf + written, "  -.-    " );
+
+
+          written += sprintf( buf + written, "(%5d) 0x%08x  ", entry->pid, entry->id );
+
+          written += sprintf( buf + written, "%-24s  ", entry->name[0] ? entry->name : "" );
+
+          written += class->Print( entry, entries->ctx, buf + written );
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&entries->lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+
+     return (written<0) ? 0 : written;
+}
+
+int
+fusion_entry_create( FusionEntries *entries,
+                     int           *ret_id )
+{
+     int               ret;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+     FUSION_ASSERT( ret_id != NULL );
+
+     class = entries->class;
+
+     entry = kmalloc( class->object_size, GFP_KERNEL );
+     if (!entry)
+          return -ENOMEM;
+
+     memset( entry, 0, class->object_size );
+
+     if (down_interruptible( &entries->lock )) {
+          kfree( entry );
+          return -EINTR;
+     }
+
+     entry->entries = entries;
+     entry->id      = entries->ids++;
+     entry->pid     = current->pid;
+
+     init_MUTEX( &entry->lock );
+
+     init_waitqueue_head( &entry->wait );
+
+     if (class->Init) {
+          ret = class->Init( entry, entries->ctx );
+          if (ret) {
+               kfree( entry );
+               return ret;
+          }
+     }
+
+     fusion_list_prepend( &entries->list, &entry->link );
+
+     up( &entries->lock );
+
+     *ret_id = entry->id;
+
+     return 0;
+}
+
+int
+fusion_entry_destroy( FusionEntries  *entries,
+                      int             id )
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Remove the entry from the list. */
+     fusion_list_remove( &entries->list, &entry->link );
+
+     /* Wake up any waiting process. */
+     wake_up_interruptible_all( &entry->wait );
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+
+     /* Call the destroy function. */
+     if (class->Destroy)
+          class->Destroy( entry, entries->ctx );
+
+     /* Deallocate the entry. */
+     kfree( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_set_info( FusionEntries         *entries,
+                       const FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( entry->name, FUSION_ENTRY_INFO_NAME_LENGTH, info->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_get_info( FusionEntries   *entries,
+                       FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( info->name, FUSION_ENTRY_INFO_NAME_LENGTH, entry->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_lock( FusionEntries  *entries,
+                   int             id,
+                   FusionEntry   **ret_entry )
+{
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( ret_entry != NULL );
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     FUSION_ASSUME( entry->lock_pid != current->pid );
+
+     /* Move the entry to the front of all entries. */
+     fusion_list_move_to_front( &entries->list, &entry->link );
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Mark as locked. */
+     entry->lock_pid = current->pid;
+
+     /* Keep timestamp, but use the slightly
+        inexact version to avoid performance impacts. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) && defined _STRUCT_TIMESPEC
+     entry->last_lock.tv_sec = xtime.tv_sec;
+     entry->last_lock.tv_usec = xtime.tv_nsec / 1000;
+#else
+     entry->last_lock = xtime;
+#endif
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+     /* Return the locked entry. */
+     *ret_entry = entry;
+
+     return 0;
+}
+
+void
+fusion_entry_unlock( FusionEntry *entry )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     entry->lock_pid = 0;
+
+     /* Unlock the entry. */
+     up( &entry->lock );
+}
+
+int
+fusion_entry_wait( FusionEntry *entry, long *timeout )
+{
+     int            ret;
+     int            id;
+     FusionEntries *entries;
+     FusionEntry   *entry2;
+
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSERT( entry->entries != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     id      = entry->id;
+     entries = entry->entries;
+
+     entry->waiters++;
+
+     fusion_sleep_on( &entry->wait, &entry->lock, timeout );
+
+     entry->waiters--;
+
+     if (timeout && !*timeout)
+          return -ETIMEDOUT;
+
+     if (signal_pending(current))
+          return -EINTR;
+
+     ret = fusion_entry_lock( entries, id, &entry2 );
+     switch (ret) {
+          case -EINVAL:
+               return -EIDRM;
+
+          case 0:
+               if (entry != entry2)
+                    BUG();
+     }
+
+     return ret;
+}
+
+void
+fusion_entry_notify( FusionEntry *entry, bool all )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     if (!entry->waiters)
+          return;
+
+     if (all)
+          wake_up_interruptible_all( &entry->wait );
+     else
+          wake_up_interruptible( &entry->wait );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/entries.h linux-2.6.12/drivers/char/_fusion_/entries.h
--- linux-2.6.12.orig/drivers/char/_fusion_/entries.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/entries.h	2004-12-12 15:09:40.000000000 +0100
@@ -0,0 +1,174 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__ENTRIES_H__
+#define __FUSION__ENTRIES_H__
+
+#include "types.h"
+#include "list.h"
+
+
+typedef struct __FD_FusionEntry FusionEntry;
+
+
+typedef const struct {
+     int object_size;
+
+     int  (*Init)   ( FusionEntry *entry, void *ctx );
+     void (*Destroy)( FusionEntry *entry, void *ctx );
+     int  (*Print)  ( FusionEntry *entry, void *ctx, char *buf );
+} FusionEntryClass;
+
+
+typedef struct {
+     FusionEntryClass  *class;
+     void              *ctx;
+
+     FusionLink        *list;
+     int                ids;
+     struct semaphore   lock;
+} FusionEntries;
+
+
+struct __FD_FusionEntry {
+     FusionLink         link;
+
+     FusionEntries     *entries;
+
+     int                id;
+     pid_t              pid;
+
+     pid_t              lock_pid;
+
+     struct semaphore   lock;
+     wait_queue_head_t  wait;
+     int                waiters;
+
+     struct timeval     last_lock;
+
+     char               name[FUSION_ENTRY_INFO_NAME_LENGTH];
+};
+
+
+/* Entries Init & DeInit */
+
+void fusion_entries_init  ( FusionEntries    *entries,
+                            FusionEntryClass *class,
+                            void             *ctx );
+
+void fusion_entries_deinit( FusionEntries    *entries );
+
+
+/* '/proc' support */
+
+int  fusion_entries_read_proc( char *buf, char **start, off_t offset,
+                               int len, int *eof, void *private );
+
+
+/* Create & Destroy */
+
+int  fusion_entry_create  ( FusionEntries    *entries,
+                            int              *ret_id );
+
+int  fusion_entry_destroy ( FusionEntries    *entries,
+                            int               id );
+
+
+/* Information */
+
+int  fusion_entry_set_info( FusionEntries          *entries,
+                            const FusionEntryInfo  *info );
+
+int  fusion_entry_get_info( FusionEntries          *entries,
+                            FusionEntryInfo        *info );
+
+
+/* Lock & Unlock */
+
+int  fusion_entry_lock    ( FusionEntries    *entries,
+                            int               id,
+                            FusionEntry     **ret_entry );
+
+void fusion_entry_unlock  ( FusionEntry      *entry );
+
+
+/** Wait & Notify **/
+
+/*
+ * Wait for the entry to be notified with an optional timeout.
+ *
+ * The entry
+ *   (1) has to be locked prior to calling this function.
+ *   (2) is temporarily unlocked while being waited for.
+ *
+ * If this function returns an error, the entry is not locked again!
+ *
+ * Possible errors are:
+ *   -EIDRM      Entry has been removed while being waited for.
+ *   -ETIMEDOUT  Timeout occured.
+ *   -EINTR      A signal has been received.
+ */
+int  fusion_entry_wait    ( FusionEntry      *entry,
+                            long             *timeout );
+
+/*
+ * Wake up one or all processes waiting for the entry to be notified.
+ *
+ * The entry has to be locked prior to calling this function.
+ */
+void fusion_entry_notify  ( FusionEntry      *entry,
+                            bool              all );
+
+
+#define FUSION_ENTRY_CLASS( Type, name, init_func, destroy_func, print_func )   \
+                                                                                \
+     static FusionEntryClass name##_class = {                                   \
+          .object_size = sizeof(Type),                                          \
+          .Init        = init_func,                                             \
+          .Destroy     = destroy_func,                                          \
+          .Print       = print_func                                             \
+     };                                                                         \
+                                                                                \
+     static inline int fusion_##name##_lock( FusionEntries  *entries,           \
+                                             int             id,                \
+                                             Type          **ret_##name )       \
+     {                                                                          \
+          int          ret;                                                     \
+          FusionEntry *entry;                                                   \
+                                                                                \
+          ret = fusion_entry_lock( entries, id, &entry );                       \
+                                                                                \
+          if (!ret)                                                             \
+               *ret_##name = (Type *) entry;                                    \
+                                                                                \
+          return ret;                                                           \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_unlock( Type *name )                    \
+     {                                                                          \
+          fusion_entry_unlock( (FusionEntry*) name );                           \
+     }                                                                          \
+                                                                                \
+     static inline int fusion_##name##_wait( Type *name, long *timeout )        \
+     {                                                                          \
+          return fusion_entry_wait( (FusionEntry*) name, timeout );             \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_notify( Type *name, bool all )          \
+     {                                                                          \
+          fusion_entry_notify( (FusionEntry*) name, all );                      \
+     }
+
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fifo.c linux-2.6.12/drivers/char/_fusion_/fifo.c
--- linux-2.6.12.orig/drivers/char/_fusion_/fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fifo.c	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "fifo.h"
+
+void
+fusion_fifo_put (FusionFifo *fifo, FusionLink *link)
+{
+     link->prev = fifo->last;
+     link->next = NULL;
+
+     if (fifo->last)
+          fifo->last->next = link;
+     else
+          fifo->first = link;
+
+     fifo->last = link;
+
+     fifo->count++;
+}
+
+FusionLink *
+fusion_fifo_get (FusionFifo *fifo)
+{
+     FusionLink *first = fifo->first;
+
+     if (!first)
+          return NULL;
+
+     fifo->first = first->next;
+
+     if (fifo->last == first)
+          fifo->last = NULL;
+     else
+          fifo->first->prev = NULL;
+
+     fifo->count--;
+
+     return first;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fifo.h linux-2.6.12/drivers/char/_fusion_/fifo.h
--- linux-2.6.12.orig/drivers/char/_fusion_/fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fifo.h	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__FIFO_H__
+#define __FUSION__FIFO_H__
+
+#include "types.h"
+#include "list.h"
+
+typedef struct {
+     FusionLink *first;
+     FusionLink *last;
+
+     int         count;
+} FusionFifo;
+
+void        fusion_fifo_put   (FusionFifo *fifo,
+                               FusionLink *link);
+
+FusionLink *fusion_fifo_get   (FusionFifo *fifo);
+
+int         fusion_fifo_count (FusionFifo *fifo);
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.c linux-2.6.12/drivers/char/_fusion_/fusiondev.c
--- linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusiondev.c	2004-11-26 12:16:28.000000000 +0100
@@ -0,0 +1,956 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+#include <linux/device.h>
+#endif
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+#ifndef FUSION_MAJOR
+#define FUSION_MAJOR 252
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Denis Oliver Kropp <dok@directfb.org>");
+
+struct proc_dir_entry *proc_fusion_dir;
+
+#define NUM_MINORS 8
+
+static FusionDev  *fusion_devs[NUM_MINORS] = { 0 };
+static DECLARE_MUTEX(devs_lock);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static devfs_handle_t devfs_handles[NUM_MINORS];
+static inline unsigned iminor(struct inode *inode)
+{
+        return MINOR(inode->i_rdev);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+static struct class_simple *fusion_class;
+#endif
+
+/******************************************************************************/
+
+void
+fusion_sleep_on(wait_queue_head_t *q, struct semaphore *lock, signed long *timeout)
+{
+     wait_queue_t wait;
+
+     init_waitqueue_entry (&wait, current);
+
+     current->state = TASK_INTERRUPTIBLE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+     spin_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     spin_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+#else
+     write_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     write_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+#endif
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_stat_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionDev *dev     = private;
+     int        written = 0;
+
+     written += snprintf( buf, len,
+                          "lease/purchase   cede      attach     detach      "
+                          "ref up   ref down  prevail/swoop dismiss\n" );
+     if (written < offset) {
+          offset -= written;
+          written = 0;
+     }
+
+     if (written < len) {
+          written += snprintf( buf+written, len - written,
+                               "%10d %10d  %10d %10d  %10d %10d  %10d %10d\n",
+                               dev->stat.property_lease_purchase,
+                               dev->stat.property_cede,
+                               dev->stat.reactor_attach,
+                               dev->stat.reactor_detach,
+                               dev->stat.ref_up,
+                               dev->stat.ref_down,
+                               dev->stat.skirmish_prevail_swoop,
+                               dev->stat.skirmish_dismiss );
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+     }
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_init (FusionDev *dev)
+{
+     int ret;
+
+     ret = fusionee_init (dev);
+     if (ret)
+          goto error_fusionee;
+
+     ret = fusion_ref_init (dev);
+     if (ret)
+          goto error_ref;
+
+     ret = fusion_skirmish_init (dev);
+     if (ret)
+          goto error_skirmish;
+
+     ret = fusion_property_init (dev);
+     if (ret)
+          goto error_property;
+
+     ret = fusion_reactor_init (dev);
+     if (ret)
+          goto error_reactor;
+
+     ret = fusion_call_init (dev);
+     if (ret)
+          goto error_call;
+
+     create_proc_read_entry("stat", 0, dev->proc_dir,
+                            fusiondev_stat_read_proc, dev);
+
+     return 0;
+
+
+error_call:
+     fusion_reactor_deinit (dev);
+
+error_reactor:
+     fusion_property_deinit (dev);
+
+error_property:
+     fusion_skirmish_deinit (dev);
+
+error_skirmish:
+     fusion_ref_deinit (dev);
+
+error_ref:
+     fusionee_deinit (dev);
+
+error_fusionee:
+     return ret;
+}
+
+static void
+fusiondev_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("stat", dev->proc_dir);
+
+     fusion_call_deinit (dev);
+     fusion_reactor_deinit (dev);
+     fusion_property_deinit (dev);
+     fusion_skirmish_deinit (dev);
+     fusion_ref_deinit (dev);
+     fusionee_deinit (dev);
+}
+
+/******************************************************************************/
+
+static int
+fusion_open (struct inode *inode, struct file *file)
+{
+     int ret;
+     int fusion_id;
+     int minor = iminor(inode);
+
+     DEBUG( "fusion_open\n" );
+
+     if (down_interruptible (&devs_lock))
+          return -EINTR;
+
+     if (!fusion_devs[minor]) {
+          char buf[4];
+
+          fusion_devs[minor] = kmalloc (sizeof(FusionDev), GFP_KERNEL);
+          if (!fusion_devs[minor]) {
+               up (&devs_lock);
+               return -ENOMEM;
+          }
+
+          memset (fusion_devs[minor], 0, sizeof(FusionDev));
+
+          snprintf (buf, 4, "%d", minor);
+
+          fusion_devs[minor]->proc_dir = proc_mkdir (buf, proc_fusion_dir);
+
+          ret = fusiondev_init (fusion_devs[minor]);
+          if (ret) {
+               remove_proc_entry (buf, proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+
+               up (&devs_lock);
+
+               return ret;
+          }
+     }
+     else if (file->f_flags & O_EXCL) {
+          up (&devs_lock);
+          return -EBUSY;
+     }
+
+     ret = fusionee_new (fusion_devs[minor], &fusion_id);
+     if (ret) {
+          if (!fusion_devs[minor]->refs) {
+               fusiondev_deinit (fusion_devs[minor]);
+
+               remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                                  proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+          }
+
+          up (&devs_lock);
+
+          return ret;
+     }
+
+     fusion_devs[minor]->refs++;
+
+     up (&devs_lock);
+
+
+     file->private_data = (void*) fusion_id;
+
+     return 0;
+}
+
+static int
+fusion_release (struct inode *inode, struct file *file)
+{
+     int ret;
+     int minor     = iminor(inode);
+     int fusion_id = (int) file->private_data;
+
+     DEBUG( "fusion_release\n" );
+
+     ret = fusionee_destroy (fusion_devs[minor], fusion_id);
+     if (ret)
+          return ret;
+
+     down (&devs_lock);
+
+     if (! --fusion_devs[minor]->refs) {
+          fusiondev_deinit (fusion_devs[minor]);
+
+          remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                             proc_fusion_dir);
+
+          kfree (fusion_devs[minor]);
+          fusion_devs[minor] = NULL;
+     }
+
+     up (&devs_lock);
+
+     return 0;
+}
+
+static int
+fusion_flush (struct file *file)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     (void) fusion_id;
+
+     DEBUG( "fusion_flush (0x%08x %d)\n", fusion_id, current->pid );
+
+     if (current->flags & PF_EXITING)
+          fusion_skirmish_dismiss_all_from_pid (dev, current->pid);
+
+     return 0;
+}
+
+static ssize_t
+fusion_read (struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_read (%d)\n", count );
+
+     return fusionee_get_messages (dev, fusion_id, buf, count,
+                                   !(file->f_flags & O_NONBLOCK));
+}
+
+static unsigned int
+fusion_poll (struct file *file, poll_table * wait)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_poll\n" );
+
+     return fusionee_poll (dev, fusion_id, file, wait);
+}
+
+static int
+lounge_ioctl (FusionDev *dev, int fusion_id,
+              unsigned int cmd, unsigned long arg)
+{
+     int             ret;
+     FusionEnter     enter;
+     FusionKill      kill;
+     FusionEntryInfo info;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_ENTER):
+               if (copy_from_user (&enter, (FusionEnter*) arg, sizeof(enter)))
+                    return -EFAULT;
+
+               if (enter.api.major != FUSION_API_MAJOR || enter.api.minor > FUSION_API_MINOR)
+                    return -ENOPROTOOPT;
+
+               enter.fusion_id = fusion_id;
+
+               if (copy_to_user ((FusionEnter*) arg, &enter, sizeof(enter)))
+                    return -EFAULT;
+
+               return 0;
+
+          case _IOC_NR(FUSION_KILL):
+               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
+                    return -EFAULT;
+
+               return fusionee_kill (dev, fusion_id,
+                                     kill.fusion_id, kill.signal, kill.timeout_ms);
+
+          case _IOC_NR(FUSION_ENTRY_SET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         return fusion_entry_set_info (&dev->skirmish, &info);
+
+                    case FT_PROPERTY:
+                         return fusion_entry_set_info (&dev->properties, &info);
+
+                    case FT_REACTOR:
+                         return fusion_entry_set_info (&dev->reactor, &info);
+
+                    default:
+                         return -ENOSYS;
+               }
+
+          case _IOC_NR(FUSION_ENTRY_GET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         ret = fusion_entry_get_info (&dev->skirmish, &info);
+                         break;
+
+                    case FT_PROPERTY:
+                         ret = fusion_entry_get_info (&dev->properties, &info);
+                         break;
+
+                    case FT_REACTOR:
+                         ret = fusion_entry_get_info (&dev->reactor, &info);
+                         break;
+
+                    default:
+                         return -ENOSYS;
+               }
+
+               if (ret)
+                    return ret;
+
+               if (copy_to_user ((FusionEntryInfo*) arg, &info, sizeof(info)))
+                    return -EFAULT;
+
+               return 0;
+     }
+
+     return -ENOSYS;
+}
+
+static int
+messaging_ioctl (FusionDev *dev, int fusion_id,
+                 unsigned int cmd, unsigned long arg)
+{
+     FusionSendMessage send;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SEND_MESSAGE):
+               if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
+                    return -EFAULT;
+
+               if (send.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (send.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusionee_send_message (dev, fusion_id, send.fusion_id, FMT_SEND,
+                                             send.msg_id, send.msg_size, send.msg_data);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+call_ioctl (FusionDev *dev, int fusion_id,
+            unsigned int cmd, unsigned long arg)
+{
+     int               id;
+     int               ret;
+     FusionCallNew     call;
+     FusionCallExecute execute;
+     FusionCallReturn  call_ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_CALL_NEW):
+               if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
+                    return -EFAULT;
+
+               ret = fusion_call_new (dev, fusion_id, &call);
+               if (ret)
+                    return ret;
+
+               if (put_user (call.call_id, (int*) arg)) {
+                    fusion_call_destroy (dev, fusion_id, call.call_id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_EXECUTE):
+               if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
+                    return -EFAULT;
+
+               ret = fusion_call_execute (dev, fusion_id, &execute);
+               if (ret)
+                    return ret;
+
+               if (put_user (execute.ret_val, (int*) arg))
+                    return -EFAULT;
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_RETURN):
+               if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
+                    return -EFAULT;
+
+               return fusion_call_return (dev, fusion_id, &call_ret);
+
+          case _IOC_NR(FUSION_CALL_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_call_destroy (dev, fusion_id, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+ref_ioctl (FusionDev *dev, int fusion_id,
+           unsigned int cmd, unsigned long arg)
+{
+     int              id;
+     int              ret;
+     int              refs;
+     FusionRefWatch   watch;
+     FusionRefInherit inherit;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REF_NEW):
+               ret = fusion_ref_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_ref_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REF_UP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UP_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_DOWN):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_DOWN_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_ZERO_LOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_lock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_ZERO_TRYLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_trylock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UNLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_unlock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_STAT):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               ret = fusion_ref_stat (dev, id, &refs);
+               if (ret)
+                    return ret;
+
+               return refs;
+
+          case _IOC_NR(FUSION_REF_WATCH):
+               if (copy_from_user (&watch, (FusionRefWatch*) arg, sizeof(watch)))
+                    return -EFAULT;
+
+               return fusion_ref_watch (dev, watch.id, watch.call_id, watch.call_arg);
+
+          case _IOC_NR(FUSION_REF_INHERIT):
+               if (copy_from_user (&inherit, (FusionRefInherit*) arg, sizeof(inherit)))
+                    return -EFAULT;
+
+               return fusion_ref_inherit (dev, inherit.id, inherit.from);
+
+          case _IOC_NR(FUSION_REF_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+skirmish_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SKIRMISH_NEW):
+               ret = fusion_skirmish_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_skirmish_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_SKIRMISH_PREVAIL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_prevail (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_SWOOP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_swoop (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DISMISS):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_dismiss (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+property_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_PROPERTY_NEW):
+               ret = fusion_property_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_property_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_PROPERTY_LEASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_lease (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_PURCHASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_purchase (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_CEDE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_cede (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_HOLDUP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_holdup (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+reactor_ioctl (FusionDev *dev, int fusion_id,
+               unsigned int cmd, unsigned long arg)
+{
+     int                   id;
+     int                   ret;
+     FusionReactorDispatch dispatch;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REACTOR_NEW):
+               ret = fusion_reactor_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_reactor_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REACTOR_ATTACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_attach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DETACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_detach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DISPATCH):
+               if (copy_from_user (&dispatch,
+                                   (FusionReactorDispatch*) arg, sizeof(dispatch)))
+                    return -EFAULT;
+
+               if (dispatch.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (dispatch.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusion_reactor_dispatch (dev, dispatch.reactor_id,
+                                               dispatch.self ? 0 : fusion_id,
+                                               dispatch.msg_size, dispatch.msg_data);
+
+          case _IOC_NR(FUSION_REACTOR_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+fusion_ioctl (struct inode *inode, struct file *file,
+              unsigned int cmd, unsigned long arg)
+{
+     int        id  = (int) file->private_data;
+     FusionDev *dev = fusion_devs[iminor(inode)];
+
+     DEBUG( "fusion_ioctl (0x%08x)\n", cmd );
+
+     switch (_IOC_TYPE(cmd)) {
+          case FT_LOUNGE:
+               return lounge_ioctl( dev, id, cmd, arg );
+
+          case FT_MESSAGING:
+               return messaging_ioctl( dev, id, cmd, arg );
+
+          case FT_CALL:
+               return call_ioctl( dev, id, cmd, arg );
+
+          case FT_REF:
+               return ref_ioctl( dev, id, cmd, arg );
+
+          case FT_SKIRMISH:
+               return skirmish_ioctl( dev, id, cmd, arg );
+
+          case FT_PROPERTY:
+               return property_ioctl( dev, id, cmd, arg );
+
+          case FT_REACTOR:
+               return reactor_ioctl( dev, id, cmd, arg );
+     }
+
+     return -ENOSYS;
+}
+
+static struct file_operations fusion_fops = {
+     .owner   = THIS_MODULE,
+     .open    = fusion_open,
+     .flush   = fusion_flush,
+     .release = fusion_release,
+     .read    = fusion_read,
+     .poll    = fusion_poll,
+     .ioctl   = fusion_ioctl
+};
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static int __init
+register_devices(void)
+{
+     int  i;
+
+     if (register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     fusion_class = class_simple_create (THIS_MODULE, "fusion");
+     if (IS_ERR(fusion_class)) {
+          unregister_chrdev (FUSION_MAJOR, "fusion");
+          return PTR_ERR(fusion_class);
+     }
+#endif
+
+     devfs_mk_dir("fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_add (fusion_class,
+                                   MKDEV(FUSION_MAJOR, i),
+                                   NULL, "fusion%d", i);
+#endif
+
+          devfs_mk_cdev (MKDEV(FUSION_MAJOR, i),
+                         S_IFCHR | S_IRUSR | S_IWUSR,
+                         "fusion/%d", i);
+     }
+
+     return 0;
+}
+#else
+static int __init
+register_devices(void)
+{
+     int  i;
+     char buf[16];
+
+     if (devfs_register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+     for (i=0; i<NUM_MINORS; i++) {
+          snprintf (buf, 16, "fusion/%d", i);
+
+          devfs_handles[i] = devfs_register (NULL, buf, DEVFS_FL_DEFAULT,
+                                             FUSION_MAJOR, i,
+                                             S_IFCHR | S_IRUSR | S_IWUSR,
+                                             &fusion_fops, NULL);
+     }
+
+     return 0;
+}
+#endif
+
+int __init
+fusion_init(void)
+{
+     int ret;
+
+     ret = register_devices();
+     if (ret)
+          return ret;
+
+     proc_fusion_dir = proc_mkdir ("fusion", NULL);
+
+     return 0;
+}
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_remove (MKDEV(FUSION_MAJOR, i));
+#endif
+
+          devfs_remove ("fusion/%d", i);
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     class_simple_destroy (fusion_class);
+#endif
+
+     devfs_remove ("fusion");
+}
+#else
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     devfs_unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++)
+          devfs_unregister (devfs_handles[i]);
+}
+#endif
+
+void __exit
+fusion_exit(void)
+{
+     deregister_devices();
+
+     remove_proc_entry ("fusion", NULL);
+}
+
+module_init(fusion_init);
+module_exit(fusion_exit);
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.h linux-2.6.12/drivers/char/_fusion_/fusiondev.h
--- linux-2.6.12.orig/drivers/char/_fusion_/fusiondev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusiondev.h	2004-11-16 21:22:38.000000000 +0100
@@ -0,0 +1,79 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSIONDEV_H__
+#define __FUSIONDEV_H__
+
+#include <linux/proc_fs.h>
+
+#include "entries.h"
+#include "list.h"
+
+#define FUSION_ASSERT(exp)    if (!(exp)) BUG()
+#define FUSION_ASSUME(exp)    if (!(exp)) printk( KERN_ERR "fusiondev: assumption '" #exp "' failed!\n" )
+
+typedef struct {
+     int refs;
+
+     struct proc_dir_entry *proc_dir;
+
+     struct {
+          int property_lease_purchase;
+          int property_cede;
+
+          int reactor_attach;
+          int reactor_detach;
+
+          int ref_up;
+          int ref_down;
+
+          int skirmish_prevail_swoop;
+          int skirmish_dismiss;
+     } stat;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } call;
+
+     struct {
+          int                last_id;
+          FusionLink        *list;
+          struct semaphore   lock;
+          wait_queue_head_t  wait;
+     } fusionee;
+
+     FusionEntries  properties;
+
+     FusionEntries  reactor;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } ref;
+
+     FusionEntries  skirmish;
+} FusionDev;
+
+/*
+ * Special version of interruptible_sleep_on() that unlocks the mutex
+ * after adding the entry to the queue (just before schedule).
+ */
+void fusion_sleep_on (wait_queue_head_t *q,
+                      struct semaphore  *lock,
+                      signed long       *timeout_ms);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusionee.c linux-2.6.12/drivers/char/_fusion_/fusionee.c
--- linux-2.6.12.orig/drivers/char/_fusion_/fusionee.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusionee.c	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,507 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fifo.h"
+#include "list.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+typedef struct {
+     FusionLink        link;
+
+     struct semaphore  lock;
+
+     int               id;
+     int               pid;
+
+     FusionFifo        messages;
+
+     int               rcv_total;  /* Total number of messages received. */
+     int               snd_total;  /* Total number of messages sent. */
+
+     wait_queue_head_t wait;
+} Fusionee;
+
+typedef struct {
+     FusionLink         link;
+
+     FusionMessageType  type;
+     int                id;
+     int                size;
+     void              *data;
+} Message;
+
+/******************************************************************************/
+
+static int  lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static int  lock_fusionee   (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static void unlock_fusionee (Fusionee *fusionee);
+
+/******************************************************************************/
+
+static int
+fusionees_read_proc(char *buf, char **start, off_t offset,
+                    int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee*) l;
+
+          written += sprintf(buf+written, "(%5d) 0x%08x (%4d messages waiting, %7d received, %7d sent)\n",
+                             fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->fusionee.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusionee_init (FusionDev *dev)
+{
+     init_waitqueue_head (&dev->fusionee.wait);
+
+     init_MUTEX (&dev->fusionee.lock);
+
+     create_proc_read_entry("fusionees", 0, dev->proc_dir,
+                            fusionees_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusionee_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->fusionee.lock);
+
+     remove_proc_entry ("fusionees", dev->proc_dir);
+
+     l = dev->fusionee.list;
+     while (l) {
+          FusionLink *next     = l->next;
+          Fusionee   *fusionee = (Fusionee *) l;
+
+          while (fusionee->messages.count) {
+               Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+               kfree (message);
+          }
+
+          kfree (fusionee);
+
+          l = next;
+     }
+
+     up (&dev->fusionee.lock);
+}
+
+/******************************************************************************/
+
+int
+fusionee_new (FusionDev *dev, int *id)
+{
+     Fusionee *fusionee;
+
+     fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
+     if (!fusionee)
+          return -ENOMEM;
+
+     memset (fusionee, 0, sizeof(Fusionee));
+
+     if (down_interruptible (&dev->fusionee.lock)) {
+          kfree (fusionee);
+          return -EINTR;
+     }
+
+     fusionee->id  = ++dev->fusionee.last_id;
+     fusionee->pid = current->pid;
+
+     init_MUTEX (&fusionee->lock);
+
+     init_waitqueue_head (&fusionee->wait);
+
+     fusion_list_prepend (&dev->fusionee.list, &fusionee->link);
+
+     up (&dev->fusionee.lock);
+
+     *id = fusionee->id;
+
+     return 0;
+}
+
+int
+fusionee_send_message (FusionDev *dev, int id, int recipient,
+                       FusionMessageType msg_type, int msg_id,
+                       int msg_size, const void *msg_data)
+{
+     int       ret;
+     Message  *message;
+     Fusionee *sender   = NULL;
+     Fusionee *fusionee;
+
+     DEBUG( "fusionee_send_message (%d -> %d, type %d, id %d, size %d)\n",
+            id, recipient, msg_type, msg_id, msg_size );
+
+     ret = lock_fusionee (dev, recipient, &fusionee);
+     if (ret)
+          return ret;
+
+     if (id) {
+          if (id == recipient) {
+               sender = fusionee;
+          }
+          else {
+               ret = lock_fusionee (dev, id, &sender);
+               if (ret) {
+                    unlock_fusionee (fusionee);
+                    return ret == -EINVAL ? -EIO : ret;
+               }
+          }
+     }
+
+     message = kmalloc (sizeof(Message) + msg_size, GFP_KERNEL);
+     if (!message) {
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -ENOMEM;
+     }
+
+     message->data = message + 1;
+
+     if (msg_type == FMT_CALL)
+          memcpy (message->data, msg_data, msg_size);
+     else if (copy_from_user (message->data, msg_data, msg_size)) {
+          kfree (message);
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -EFAULT;
+     }
+
+     message->type = msg_type;
+     message->id   = msg_id;
+     message->size = msg_size;
+
+     fusion_fifo_put (&fusionee->messages, &message->link);
+
+     fusionee->rcv_total++;
+     if (sender)
+          sender->snd_total++;
+
+     wake_up_interruptible_all (&fusionee->wait);
+
+     if (sender && sender != fusionee)
+          unlock_fusionee (sender);
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_get_messages (FusionDev *dev,
+                       int id, void *buf, int buf_size, bool block)
+{
+     int       ret;
+     int       written  = 0;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     while (!fusionee->messages.count) {
+          if (!block) {
+               unlock_fusionee (fusionee);
+               return -EAGAIN;
+          }
+
+          fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
+
+          if (signal_pending(current))
+               return -EINTR;
+
+          ret = lock_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+     }
+
+     while (fusionee->messages.count) {
+          FusionReadMessage  header;
+          Message           *message = (Message*) fusionee->messages.first;
+          int                bytes   = message->size + sizeof(header);
+
+          if (bytes > buf_size) {
+               if (!written) {
+                    unlock_fusionee (fusionee);
+                    return -EMSGSIZE;
+               }
+
+               break;
+          }
+
+          header.msg_type = message->type;
+          header.msg_id   = message->id;
+          header.msg_size = message->size;
+
+          if (copy_to_user (buf, &header, sizeof(header)) ||
+              copy_to_user (buf + sizeof(header), message->data, message->size)) {
+               unlock_fusionee (fusionee);
+               return -EFAULT;
+          }
+
+          written  += bytes;
+          buf      += bytes;
+          buf_size -= bytes;
+
+          fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     unlock_fusionee (fusionee);
+
+     return written;
+}
+
+unsigned int
+fusionee_poll (FusionDev *dev, int id, struct file *file, poll_table * wait)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     unlock_fusionee (fusionee);
+
+
+     poll_wait (file, &fusionee->wait, wait);
+
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (!fusionee)
+          return -EINVAL;
+
+     if (fusionee->messages.count) {
+          unlock_fusionee (fusionee);
+
+          return POLLIN | POLLRDNORM;
+     }
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_kill (FusionDev *dev, int id, int target, int signal, int timeout_ms)
+{
+     long timeout = -1;
+
+     while (true) {
+          int         ret;
+          FusionLink *l;
+          Fusionee   *fusionee;
+          int         killed   = 0;
+
+          ret = lookup_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+
+          fusion_list_foreach (l, dev->fusionee.list) {
+               Fusionee *f = (Fusionee*) l;
+
+               if (f->id != id && (!target || target == f->id)) {
+                    kill_proc (f->pid, signal, 0);
+                    killed++;
+               }
+          }
+
+          if (!killed || timeout_ms < 0)
+               break;
+
+          if (timeout_ms) {
+               switch (timeout) {
+                    case 0:  /* timed out */
+                         up (&dev->fusionee.lock);
+                         return -ETIMEDOUT;
+
+                    case -1: /* setup timeout */
+                         timeout = (timeout_ms * HZ + 500) / 1000;
+                         if (!timeout)
+                              timeout = 1;
+
+                         /* fall through */
+
+                    default:
+                         fusion_sleep_on (&dev->fusionee.wait,
+                                          &dev->fusionee.lock, &timeout);
+                         break;
+               }
+          }
+          else
+               fusion_sleep_on (&dev->fusionee.wait, &dev->fusionee.lock, NULL);
+
+          if (signal_pending(current))
+               return -EINTR;
+     }
+
+     up (&dev->fusionee.lock);
+
+     return 0;
+}
+
+int
+fusionee_destroy (FusionDev *dev, int id)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     down (&fusionee->lock);
+
+     fusion_list_remove (&dev->fusionee.list, &fusionee->link);
+
+     wake_up_interruptible_all (&dev->fusionee.wait);
+
+     up (&dev->fusionee.lock);
+
+
+     fusion_call_destroy_all (dev, id);
+     fusion_skirmish_dismiss_all (dev, id);
+     fusion_reactor_detach_all (dev, id);
+     fusion_property_cede_all (dev, id);
+     fusion_ref_clear_all_local (dev, id);
+
+     while (fusionee->messages.count) {
+          Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     up (&fusionee->lock);
+
+     kfree (fusionee);
+
+     return ret;
+}
+
+/******************************************************************************/
+
+static int
+lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee *) l;
+
+          if (fusionee->id == id) {
+               *ret_fusionee = fusionee;
+               return 0;
+          }
+     }
+
+     up (&dev->fusionee.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (fusionee) {
+          fusion_list_move_to_front (&dev->fusionee.list, &fusionee->link);
+
+          if (down_interruptible (&fusionee->lock)) {
+               up (&dev->fusionee.lock);
+               return -EINTR;
+          }
+
+          up (&dev->fusionee.lock);
+     }
+
+     *ret_fusionee = fusionee;
+
+     return 0;
+}
+
+static void
+unlock_fusionee (Fusionee *fusionee)
+{
+     up (&fusionee->lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/fusionee.h linux-2.6.12/drivers/char/_fusion_/fusionee.h
--- linux-2.6.12.orig/drivers/char/_fusion_/fusionee.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/fusionee.h	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSIONEE_H__
+#define __FUSIONEE_H__
+
+#include <linux/poll.h>
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusionee_init   (FusionDev *dev);
+void fusionee_deinit (FusionDev *dev);
+
+
+/* internal functions */
+
+int fusionee_new           (FusionDev         *dev,
+                            int               *id);
+
+int fusionee_send_message  (FusionDev         *dev,
+                            int                id,
+                            int                recipient,
+                            FusionMessageType  msg_type,
+                            int                msg_id,
+                            int                msg_size,
+                            const void        *msg_data);
+
+int fusionee_get_messages  (FusionDev         *dev,
+                            int                id,
+                            void              *buf,
+                            int                buf_size,
+                            bool               block);
+
+unsigned
+int fusionee_poll          (FusionDev         *dev,
+                            int                id,
+                            struct file       *file,
+                            poll_table        *wait);
+
+int fusionee_kill          (FusionDev         *dev,
+                            int                id,
+                            int                target,
+                            int                signal,
+                            int                timeout_ms);
+
+int fusionee_destroy       (FusionDev         *dev,
+                            int                id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/list.c linux-2.6.12/drivers/char/_fusion_/list.c
--- linux-2.6.12.orig/drivers/char/_fusion_/list.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/list.c	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "list.h"
+
+void
+fusion_list_prepend (FusionLink **list, FusionLink *link)
+{
+     link->prev = NULL;
+     link->next = *list;
+
+     if (*list)
+          (*list)->prev = link;
+
+     *list = link;
+}
+
+void
+fusion_list_remove (FusionLink **list, FusionLink *link)
+{
+     if (link->prev)
+          link->prev->next = link->next;
+     else
+          *list = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->next = link->prev = NULL;
+}
+
+void
+fusion_list_move_to_front (FusionLink **list, FusionLink *link)
+{
+     if (*list == link)
+          return;
+
+     link->prev->next = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->prev = NULL;
+     link->next = *list;
+
+     (*list)->prev = link;
+
+     *list = link;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/list.h linux-2.6.12/drivers/char/_fusion_/list.h
--- linux-2.6.12.orig/drivers/char/_fusion_/list.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/list.h	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__LIST_H__
+#define __FUSION__LIST_H__
+
+typedef struct _FusionLink {
+     struct _FusionLink *next;
+     struct _FusionLink *prev;
+} FusionLink;
+
+void fusion_list_prepend       (FusionLink **list, FusionLink *link);
+void fusion_list_remove        (FusionLink **list, FusionLink *link);
+void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
+
+
+#define fusion_list_foreach(elem, list)                     \
+     for (elem = (void*)(list);                             \
+          elem;                                             \
+          elem = (void*)(((FusionLink*)(elem))->next))
+
+#define fusion_list_foreach_safe(elem, temp, list)                                             \
+     for (elem = (void*)(list), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL); \
+          elem;                                                                                \
+          elem = (void*)(temp), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL))
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/property.c linux-2.6.12/drivers/char/_fusion_/property.c
--- linux-2.6.12.orig/drivers/char/_fusion_/property.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/property.c	2004-11-14 08:10:38.000000000 +0100
@@ -0,0 +1,337 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#ifndef yield
+#define yield schedule
+#endif
+
+#include <linux/fusion.h>
+
+#include "entries.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "property.h"
+
+typedef enum {
+     FUSION_PROPERTY_AVAILABLE = 0,
+     FUSION_PROPERTY_LEASED,
+     FUSION_PROPERTY_PURCHASED
+} FusionPropertyState;
+
+typedef struct {
+     FusionEntry         entry;
+
+     FusionPropertyState state;
+     int                 fusion_id; /* non-zero if leased/purchased */
+     unsigned long       purchase_stamp;
+     int                 lock_pid;
+     int                 count;    /* lock counter */
+} FusionProperty;
+
+static int
+fusion_property_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     FusionProperty *property = (FusionProperty*) entry;
+
+     if (property->state != FUSION_PROPERTY_AVAILABLE) {
+          return sprintf( buf, "%s by 0x%08x (%d) %dx\n",
+                          property->state == FUSION_PROPERTY_LEASED ? "leased" : "purchased",
+                          property->fusion_id, property->lock_pid, property->count );
+     }
+
+     return sprintf( buf, "\n" );
+}
+
+FUSION_ENTRY_CLASS( FusionProperty, property, NULL, NULL, fusion_property_print )
+
+/******************************************************************************/
+
+int
+fusion_property_init( FusionDev *dev )
+{
+     fusion_entries_init( &dev->properties, &property_class, dev );
+
+     create_proc_read_entry( "properties", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->properties );
+
+     return 0;
+}
+
+void
+fusion_property_deinit( FusionDev *dev )
+{
+     remove_proc_entry( "properties", dev->proc_dir );
+
+     fusion_entries_deinit( &dev->properties );
+}
+
+/******************************************************************************/
+
+int
+fusion_property_new( FusionDev *dev, int *ret_id )
+{
+     return fusion_entry_create( &dev->properties, ret_id );
+}
+
+int
+fusion_property_lease( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     long            timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state     = FUSION_PROPERTY_LEASED;
+                    property->fusion_id = fusion_id;
+                    property->lock_pid  = current->pid;
+                    property->count     = 1;
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ / 10) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ / 10;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_purchase( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     signed long     timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state          = FUSION_PROPERTY_PURCHASED;
+                    property->fusion_id      = fusion_id;
+                    property->purchase_stamp = jiffies;
+                    property->lock_pid       = current->pid;
+                    property->count          = 1;
+
+                    fusion_property_notify( property, true );
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_cede( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     bool            purchased;
+
+     dev->stat.property_cede++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->lock_pid != current->pid) {
+          fusion_property_unlock( property );
+          return -EIO;
+     }
+
+     if (--property->count) {
+          fusion_property_unlock( property );
+          return 0;
+     }
+
+     purchased = (property->state == FUSION_PROPERTY_PURCHASED);
+
+     property->state     = FUSION_PROPERTY_AVAILABLE;
+     property->fusion_id = 0;
+     property->lock_pid  = 0;
+
+     fusion_property_notify( property, true );
+
+     fusion_property_unlock( property );
+
+     if (purchased)
+          yield();
+
+     return 0;
+}
+
+int
+fusion_property_holdup( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+
+     if (fusion_id > 1)
+          return -EPERM;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->state == FUSION_PROPERTY_PURCHASED) {
+          if (property->fusion_id == fusion_id) {
+               fusion_property_unlock( property );
+               return -EIO;
+          }
+
+          fusionee_kill( dev, fusion_id, property->fusion_id, SIGKILL, -1 );
+     }
+
+     fusion_property_unlock( property );
+
+     return 0;
+}
+
+int
+fusion_property_destroy( FusionDev *dev, int id )
+{
+     return fusion_entry_destroy( &dev->properties, id );
+}
+
+void
+fusion_property_cede_all( FusionDev *dev, int fusion_id )
+{
+     FusionLink *l;
+
+     down( &dev->properties.lock );
+
+     fusion_list_foreach (l, dev->properties.list) {
+          FusionProperty *property = (FusionProperty *) l;
+
+          down( &property->entry.lock );
+
+          if (property->fusion_id == fusion_id) {
+               property->state     = FUSION_PROPERTY_AVAILABLE;
+               property->fusion_id = 0;
+               property->lock_pid  = 0;
+
+               wake_up_interruptible_all (&property->entry.wait);
+          }
+
+          up( &property->entry.lock );
+     }
+
+     up( &dev->properties.lock );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/property.h linux-2.6.12/drivers/char/_fusion_/property.h
--- linux-2.6.12.orig/drivers/char/_fusion_/property.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/property.h	2004-08-17 19:24:36.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__PROPERTY_H__
+#define __FUSION__PROPERTY_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_property_init   (FusionDev *dev);
+void fusion_property_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_property_new      (FusionDev *dev,
+                              int       *ret_id);
+
+int fusion_property_lease    (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_purchase (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_cede     (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_holdup   (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_destroy  (FusionDev *dev,
+                              int        id);
+
+
+/* internal functions */
+
+void fusion_property_cede_all (FusionDev *dev,
+                               int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/reactor.c linux-2.6.12/drivers/char/_fusion_/reactor.c
--- linux-2.6.12.orig/drivers/char/_fusion_/reactor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/reactor.c	2004-11-16 21:22:38.000000000 +0100
@@ -0,0 +1,274 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "reactor.h"
+
+typedef struct {
+     FusionLink         link;
+
+     int                fusion_id;
+
+     int                count;     /* number of attach calls */
+} ReactorNode;
+
+typedef struct {
+     FusionEntry        entry;
+
+     FusionLink        *nodes;
+
+     int                dispatch_count;
+} FusionReactor;
+
+/******************************************************************************/
+
+static ReactorNode *get_node      ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         remove_node   ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         free_all_nodes( FusionReactor *reactor );
+
+/******************************************************************************/
+
+static void
+fusion_reactor_destruct( FusionEntry *entry,
+                         void        *ctx )
+{
+     FusionReactor *reactor = (FusionReactor*) entry;
+
+     free_all_nodes( reactor );
+}
+
+static int
+fusion_reactor_print( FusionEntry *entry,
+                      void        *ctx,
+                      char        *buf )
+{
+     int            num     = 0;
+     FusionReactor *reactor = (FusionReactor*) entry;
+     FusionLink    *node    = reactor->nodes;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          num++;
+     }
+
+     return sprintf( buf, "%5dx dispatch, %d nodes\n", reactor->dispatch_count, num );
+}
+
+
+FUSION_ENTRY_CLASS( FusionReactor, reactor, NULL,
+                    fusion_reactor_destruct, fusion_reactor_print )
+
+/******************************************************************************/
+
+int
+fusion_reactor_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->reactor, &reactor_class, dev );
+
+     create_proc_read_entry( "reactors", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->reactor );
+
+     return 0;
+}
+
+void
+fusion_reactor_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("reactors", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->reactor );
+}
+
+/******************************************************************************/
+
+int
+fusion_reactor_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->reactor, ret_id );
+}
+
+int
+fusion_reactor_attach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_attach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
+          if (!node) {
+               fusion_reactor_unlock( reactor );
+               return -ENOMEM;
+          }
+
+          node->fusion_id = fusion_id;
+          node->count     = 1;
+
+          fusion_list_prepend (&reactor->nodes, &node->link);
+     }
+     else
+          node->count++;
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_detach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_detach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          fusion_reactor_unlock( reactor );
+          return -EIO;
+     }
+
+     if (! --node->count) {
+          fusion_list_remove (&reactor->nodes, &node->link);
+          kfree (node);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_dispatch (FusionDev *dev, int id, int fusion_id,
+                         int msg_size, const void *msg_data)
+{
+     int            ret;
+     FusionLink    *l;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     reactor->dispatch_count++;
+
+     fusion_list_foreach (l, reactor->nodes) {
+          ReactorNode *node = (ReactorNode *) l;
+
+          if (node->fusion_id == fusion_id)
+               continue;
+
+          fusionee_send_message (dev, fusion_id, node->fusion_id, FMT_REACTOR,
+                                 reactor->entry.id, msg_size, msg_data);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->reactor, id );
+}
+
+void
+fusion_reactor_detach_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->reactor.lock);
+
+     fusion_list_foreach (l, dev->reactor.list) {
+          FusionReactor *reactor = (FusionReactor *) l;
+
+          remove_node (reactor, fusion_id);
+     }
+
+     up (&dev->reactor.lock);
+}
+
+/******************************************************************************/
+
+static ReactorNode *
+get_node (FusionReactor *reactor,
+          int            fusion_id)
+{
+     ReactorNode *node;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id)
+               return node;
+     }
+
+     return NULL;
+}
+
+static void
+remove_node (FusionReactor *reactor, int fusion_id)
+{
+     ReactorNode *node;
+
+     down (&reactor->entry.lock);
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id) {
+               fusion_list_remove (&reactor->nodes, &node->link);
+               break;
+          }
+     }
+
+     up (&reactor->entry.lock);
+}
+
+static void
+free_all_nodes (FusionReactor *reactor)
+
+{
+     FusionLink  *n;
+     ReactorNode *node;
+
+     fusion_list_foreach_safe (node, n, reactor->nodes) {
+          kfree (node);
+     }
+
+     reactor->nodes = NULL;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/reactor.h linux-2.6.12/drivers/char/_fusion_/reactor.h
--- linux-2.6.12.orig/drivers/char/_fusion_/reactor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/reactor.h	2003-06-16 19:47:04.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__REACTOR_H__
+#define __FUSION__REACTOR_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_reactor_init   (FusionDev *dev);
+void fusion_reactor_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_reactor_new      (FusionDev  *dev,
+                             int        *id);
+
+int fusion_reactor_attach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_detach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_dispatch (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id,
+                             int         msg_size,
+                             const void *msg_data);
+
+int fusion_reactor_destroy  (FusionDev  *dev,
+                             int         id);
+
+
+/* internal functions */
+
+void fusion_reactor_detach_all (FusionDev *dev,
+                                int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/ref.c linux-2.6.12/drivers/char/_fusion_/ref.c
--- linux-2.6.12.orig/drivers/char/_fusion_/ref.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/ref.c	2004-11-07 14:20:54.000000000 +0100
@@ -0,0 +1,777 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "list.h"
+#include "call.h"
+#include "ref.h"
+
+typedef struct __Fusion_FusionRef FusionRef;
+
+typedef struct {
+     FusionLink  link;
+     int         fusion_id;
+     int         refs;
+} LocalRef;
+
+typedef struct {
+     FusionLink  link;
+     FusionRef  *ref;
+} Inheritor;
+
+struct __Fusion_FusionRef {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;
+     int                pid;
+
+     int                global;
+     int                local;
+
+     int                locked;    /* non-zero fusion id of lock owner */
+
+     bool               watched;   /* true if watch has been installed */
+     int                call_id;   /* id of call registered with a watch */
+     int                call_arg;  /* optional call parameter */
+
+     FusionRef         *inherited;
+     FusionLink        *inheritors;
+
+     FusionLink        *local_refs;
+
+     wait_queue_head_t  wait;
+};
+
+/******************************************************************************/
+
+static int  lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static int  lock_ref   (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static void unlock_ref (FusionRef *ref);
+
+static int  add_local       (FusionRef *ref, int fusion_id, int add);
+static void clear_local     (FusionDev *dev, FusionRef *ref, int fusion_id);
+static void free_all_local  (FusionRef *ref);
+
+static int  propagate_local (FusionDev *dev, FusionRef *ref, int diff);
+
+static void notify_ref      (FusionDev *dev, FusionRef *ref);
+
+static int  add_inheritor   (FusionRef *ref, FusionRef *from);
+static void remove_inheritor(FusionRef *ref, FusionRef *from);
+static void drop_inheritors (FusionDev *dev, FusionRef *ref);
+
+/******************************************************************************/
+
+static int
+refs_read_proc(char *buf, char **start, off_t offset,
+               int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef*) l;
+
+          if (ref->locked)
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d (locked by %d)\n",
+                                  ref->pid, ref->id, ref->global, ref->local,
+                                  ref->locked);
+          else
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d\n",
+                                  ref->pid, ref->id, ref->global, ref->local);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->ref.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_ref_init (FusionDev *dev)
+{
+     init_MUTEX (&dev->ref.lock);
+
+     create_proc_read_entry("refs", 0, dev->proc_dir,
+                            refs_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusion_ref_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     remove_proc_entry ("refs", dev->proc_dir);
+
+     l = dev->ref.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionRef  *ref  = (FusionRef *) l;
+
+          free_all_local (ref);
+
+          kfree (ref);
+
+          l = next;
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_ref_new (FusionDev *dev, int *id)
+{
+     FusionRef *ref;
+
+     ref = kmalloc (sizeof(FusionRef), GFP_KERNEL);
+     if (!ref)
+          return -ENOMEM;
+
+     memset (ref, 0, sizeof(FusionRef));
+
+     if (down_interruptible (&dev->ref.lock)) {
+          kfree (ref);
+          return -EINTR;
+     }
+
+     ref->id   = dev->ref.ids++;
+     ref->pid  = current->pid;
+
+     init_MUTEX (&ref->lock);
+
+     init_waitqueue_head (&ref->wait);
+
+     fusion_list_prepend (&dev->ref.list, &ref->link);
+
+     up (&dev->ref.lock);
+
+     *id = ref->id;
+
+     return 0;
+}
+
+int
+fusion_ref_up (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_up++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = add_local (ref, fusion_id, 1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, 1 );
+     }
+     else
+          ref->global++;
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_down (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_down++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = -EIO;
+          if (!ref->local)
+               goto out;
+
+          ret = add_local (ref, fusion_id, -1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, -1 );
+     }
+     else {
+          if (!ref->global) {
+               ret = -EIO;
+               goto out;
+          }
+
+          ref->global--;
+
+          if (ref->local + ref->global == 0)
+               notify_ref (dev, ref);
+     }
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_zero_lock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     while (true) {
+          ret = lock_ref (dev, false, id, &ref);
+          if (ret)
+               return ret;
+
+          if (ref->watched) {
+               unlock_ref (ref);
+               return -EACCES;
+          }
+
+          if (ref->locked) {
+               unlock_ref (ref);
+               return ref->locked == fusion_id ? -EIO : -EAGAIN;
+          }
+
+          if (ref->global || ref->local) {
+               fusion_sleep_on (&ref->wait, &ref->lock, 0);
+
+               if (signal_pending(current))
+                    return -EINTR;
+          }
+          else
+               break;
+     }
+
+     ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_zero_trylock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked) {
+          unlock_ref (ref);
+          return ref->locked == fusion_id ? -EIO : -EAGAIN;
+     }
+
+     if (ref->global || ref->local)
+          ret = -ETOOMANYREFS;
+     else
+          ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_unlock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked != fusion_id) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     ref->locked = 0;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_stat (FusionDev *dev, int id, int *refs)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     *refs = ref->global + ref->local;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_watch (FusionDev      *dev,
+                  int             id,
+                  int             call_id,
+                  int             call_arg)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->pid != current->pid) {
+          unlock_ref (ref);
+          return -EACCES;
+     }
+
+     if (ref->global + ref->local == 0) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     if (ref->watched) {
+          unlock_ref (ref);
+          return -EBUSY;
+     }
+
+     ref->watched  = true;
+     ref->call_id  = call_id;
+     ref->call_arg = call_arg;
+
+     wake_up_interruptible_all (&ref->wait);
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_inherit (FusionDev *dev,
+                    int        id,
+                    int        from_id)
+{
+     int        ret;
+     FusionRef *ref;
+     FusionRef *from = NULL;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     ret = -EBUSY;
+     if (ref->inherited)
+          goto out;
+
+     ret = lock_ref (dev, true, from_id, &from);
+     if (ret)
+          goto out;
+
+     ret = add_inheritor( ref, from );
+     if (ret)
+          goto out;
+
+     ret = propagate_local( dev, ref, from->local );
+     if (ret)
+          goto out;
+
+     ref->inherited = from;
+
+out:
+     if (from)
+          unlock_ref (from);
+
+     unlock_ref (ref);
+
+     up (&dev->ref.lock);
+
+     return ret;
+}
+
+int
+fusion_ref_destroy (FusionDev *dev, int id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     drop_inheritors( dev, ref );
+
+     if (ref->inherited)
+          remove_inheritor( ref, ref->inherited );
+
+     fusion_list_remove (&dev->ref.list, &ref->link);
+
+     wake_up_interruptible_all (&ref->wait);
+
+     up (&dev->ref.lock);
+
+     free_all_local (ref);
+
+     up (&ref->lock);
+
+     kfree (ref);
+
+     return 0;
+}
+
+void
+fusion_ref_clear_all_local (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          clear_local (dev, ref, fusion_id);
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     FusionLink *l;
+
+     if (!locked && down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          if (ref->id == id) {
+               *ret_ref = ref;
+               return 0;
+          }
+     }
+
+     if (!locked)
+          up (&dev->ref.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     int         ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, locked, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref) {
+          fusion_list_move_to_front (&dev->ref.list, &ref->link);
+
+          if (down_interruptible (&ref->lock)) {
+               if (!locked)
+                    up (&dev->ref.lock);
+               return -EINTR;
+          }
+
+          if (!locked)
+               up (&dev->ref.lock);
+     }
+
+     *ret_ref = ref;
+
+     return 0;
+}
+
+static void
+unlock_ref (FusionRef *ref)
+{
+     up (&ref->lock);
+}
+
+static int
+add_local (FusionRef *ref, int fusion_id, int add)
+{
+     FusionLink *l;
+     LocalRef   *local;
+
+     fusion_list_foreach (l, ref->local_refs) {
+          local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               fusion_list_move_to_front( &ref->local_refs, l );
+
+               if (local->refs + add < 0)
+                    return -EIO;
+
+               local->refs += add;
+               return 0;
+          }
+     }
+
+     local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
+     if (!local)
+          return -ENOMEM;
+
+     local->fusion_id = fusion_id;
+     local->refs      = add;
+
+     fusion_list_prepend (&ref->local_refs, &local->link);
+
+     return 0;
+}
+
+static void
+clear_local (FusionDev *dev, FusionRef *ref, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&ref->lock);
+
+     if (ref->locked == fusion_id) {
+          ref->locked = 0;
+          wake_up_interruptible_all (&ref->wait);
+     }
+
+     fusion_list_foreach (l, ref->local_refs) {
+          LocalRef *local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               if (local->refs)
+                    propagate_local( dev, ref, - local->refs );
+
+               fusion_list_remove( &ref->local_refs, l );
+
+               kfree (l);
+               break;
+          }
+     }
+
+     up (&ref->lock);
+}
+
+static void
+free_all_local (FusionRef *ref)
+{
+     FusionLink *l = ref->local_refs;
+
+     while (l) {
+          FusionLink *next = l->next;
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->local_refs = NULL;
+}
+
+static void
+notify_ref (FusionDev *dev, FusionRef *ref)
+{
+     if (ref->watched) {
+          FusionCallExecute execute;
+
+          execute.call_id  = ref->call_id;
+          execute.call_arg = ref->call_arg;
+          execute.call_ptr = NULL;
+
+          fusion_call_execute (dev, 0, &execute);
+     }
+     else
+          wake_up_interruptible_all (&ref->wait);
+}
+
+static int
+propagate_local( FusionDev *dev, FusionRef *ref, int diff )
+{
+     FusionLink *l;
+
+     /* Recurse into inheritors. */
+     fusion_list_foreach (l, ref->inheritors) {
+          FusionRef *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: propagate_local() interrupted!\n" );
+               //return -EINTR;
+          }
+
+          propagate_local( dev, inheritor, diff );
+
+          up( &inheritor->lock );
+     }
+
+     /* Apply difference. */
+     ref->local += diff;
+
+     /* Notify zero count. */
+     if (ref->local + ref->global == 0)
+          notify_ref( dev, ref );
+
+     return 0;
+}
+
+static int
+add_inheritor(FusionRef *ref, FusionRef *from)
+{
+     Inheritor *inheritor;
+
+     inheritor = kmalloc (sizeof(Inheritor), GFP_KERNEL);
+     if (!inheritor)
+          return -ENOMEM;
+
+     inheritor->ref = ref;
+
+     fusion_list_prepend( &from->inheritors, &inheritor->link );
+
+     return 0;
+}
+
+static void
+remove_inheritor(FusionRef *ref, FusionRef *from)
+{
+     FusionLink *l;
+
+     down( &from->lock );
+
+     fusion_list_foreach (l, from->inheritors) {
+          Inheritor *inheritor = (Inheritor*) l;
+
+          if (inheritor->ref == ref) {
+               fusion_list_remove( &from->inheritors, &inheritor->link );
+
+               kfree( l );
+               break;
+          }
+     }
+
+     up( &from->lock );
+}
+
+static void
+drop_inheritors( FusionDev *dev, FusionRef *ref )
+{
+     FusionLink *l = ref->inheritors;
+
+     while (l) {
+          FusionLink *next      = l->next;
+          FusionRef  *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: drop_inheritors() interrupted!\n" );
+               //return;
+          }
+
+          propagate_local( dev, inheritor, - ref->local );
+
+          inheritor->inherited = NULL;
+
+          up( &inheritor->lock );
+
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->inheritors = NULL;
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/ref.h linux-2.6.12/drivers/char/_fusion_/ref.h
--- linux-2.6.12.orig/drivers/char/_fusion_/ref.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/ref.h	2004-11-07 11:15:12.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__REF_H__
+#define __FUSION__REF_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_ref_init   (FusionDev *dev);
+void fusion_ref_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_ref_new          (FusionDev      *dev,
+                             int            *id);
+
+int fusion_ref_up           (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_down         (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_lock    (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_trylock (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_unlock       (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_stat         (FusionDev      *dev,
+                             int             id,
+                             int            *refs);
+
+int fusion_ref_watch        (FusionDev      *dev,
+                             int             id,
+                             int             call_id,
+                             int             call_arg);
+
+int fusion_ref_inherit      (FusionDev      *dev,
+                             int             id,
+                             int             from);
+
+int fusion_ref_destroy      (FusionDev      *dev,
+                             int             id);
+
+
+/* internal functions */
+
+void fusion_ref_clear_all_local (FusionDev *dev,
+                                 int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/skirmish.c linux-2.6.12/drivers/char/_fusion_/skirmish.c
--- linux-2.6.12.orig/drivers/char/_fusion_/skirmish.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/skirmish.c	2004-11-16 21:22:38.000000000 +0100
@@ -0,0 +1,246 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "skirmish.h"
+
+
+typedef struct {
+     FusionEntry        entry;
+
+     int                lock_fid;  /* non-zero if locked */
+     int                lock_pid;
+     int                lock_count;
+
+     int                lock_total;
+} FusionSkirmish;
+
+static int
+fusion_skirmish_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     int             written;
+     FusionSkirmish *skirmish = (FusionSkirmish*) entry;
+
+     written = sprintf( buf, "%6dx total", skirmish->lock_total );
+
+     if (skirmish->lock_fid)
+          return sprintf( buf + written, ", now %dx by 0x%08x (%d)\n",
+                          skirmish->lock_count, skirmish->lock_fid, skirmish->lock_pid) + written;
+
+     return sprintf( buf + written, "\n" ) + written;
+}
+
+FUSION_ENTRY_CLASS( FusionSkirmish, skirmish, NULL, NULL, fusion_skirmish_print )
+
+/******************************************************************************/
+
+int
+fusion_skirmish_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->skirmish, &skirmish_class, dev );
+
+     create_proc_read_entry( "skirmishs", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->skirmish );
+
+     return 0;
+}
+
+void
+fusion_skirmish_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("skirmishs", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->skirmish );
+}
+
+/******************************************************************************/
+
+int
+fusion_skirmish_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->skirmish, ret_id );
+}
+
+int
+fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     if (skirmish->lock_pid == current->pid) {
+          skirmish->lock_count++;
+          skirmish->lock_total++;
+          fusion_skirmish_unlock( skirmish );
+          return 0;
+     }
+
+     while (skirmish->lock_pid) {
+          ret = fusion_skirmish_wait( skirmish, NULL );
+          if (ret)
+               return ret;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     if (skirmish->lock_fid) {
+          if (skirmish->lock_pid == current->pid) {
+               skirmish->lock_count++;
+               skirmish->lock_total++;
+               fusion_skirmish_unlock( skirmish );
+               return 0;
+          }
+
+          fusion_skirmish_unlock( skirmish );
+
+          return -EAGAIN;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_dismiss (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_dismiss++;
+
+     if (skirmish->lock_pid != current->pid) {
+          fusion_skirmish_unlock( skirmish );
+          return -EIO;
+     }
+
+     if (--skirmish->lock_count == 0) {
+          skirmish->lock_fid = 0;
+          skirmish->lock_pid = 0;
+
+          fusion_skirmish_notify( skirmish, true );
+     }
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->skirmish, id );
+}
+
+void
+fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_fid == fusion_id) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
+void
+fusion_skirmish_dismiss_all_from_pid (FusionDev *dev, int pid)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_pid == pid) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/skirmish.h linux-2.6.12/drivers/char/_fusion_/skirmish.h
--- linux-2.6.12.orig/drivers/char/_fusion_/skirmish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/skirmish.h	2003-12-16 08:05:42.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__SKIRMISH_H__
+#define __FUSION__SKIRMISH_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_skirmish_init   (FusionDev *dev);
+void fusion_skirmish_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_skirmish_new     (FusionDev *dev,
+                             int       *id);
+
+int fusion_skirmish_prevail (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_swoop   (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_dismiss (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_destroy (FusionDev *dev,
+                             int        id);
+
+
+/* internal functions */
+
+void fusion_skirmish_dismiss_all (FusionDev *dev,
+                                  int        fusion_id);
+
+void fusion_skirmish_dismiss_all_from_pid (FusionDev *dev,
+                                           int        pid);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/_fusion_/types.h linux-2.6.12/drivers/char/_fusion_/types.h
--- linux-2.6.12.orig/drivers/char/_fusion_/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/_fusion_/types.h	2002-11-12 23:30:40.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__TYPES_H__
+#define __FUSION__TYPES_H__
+
+typedef enum {
+  false = 0,
+  true  = !false
+} bool;
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/Makefile linux-2.6.12/drivers/char/fusion/Makefile
--- linux-2.6.12.orig/drivers/char/fusion/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/Makefile	2005-06-26 00:30:38.000000000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FUSION_DEVICE) += fusion.o
+
+fusion-y := call.o entries.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/call.c linux-2.6.12/drivers/char/fusion/call.c
--- linux-2.6.12.orig/drivers/char/fusion/call.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/call.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,468 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "call.h"
+
+typedef struct {
+     FusionLink        link;
+
+     int               caller;
+
+     int               ret_val;
+
+     bool              executed;
+
+     wait_queue_head_t wait;
+} FusionCallExecution;
+
+typedef struct {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;        /* call id */
+
+     int                pid;       /* owner pid */
+     int                fusion_id; /* owner fusion id */
+
+     void              *handler;
+     void              *ctx;
+
+     FusionLink          *executions;      /* prepending! */
+     FusionLink          *last;            /* points to the last item of executions */
+
+     int                count;    /* number of calls ever made */
+} FusionCall;
+
+/******************************************************************************/
+
+static int  lookup_call (FusionDev *dev, int id, FusionCall **ret_call);
+static int  lock_call   (FusionDev *dev, int id, FusionCall **ret_call);
+static void unlock_call (FusionCall *call);
+
+static FusionCallExecution *add_execution       (FusionCall          *call,
+                                                 int                  fusion_id,
+                                                 FusionCallExecute   *execute);
+static void                 remove_execution    (FusionCall          *call,
+                                                 FusionCallExecution *execution);
+static void                 free_all_executions (FusionCall          *call);
+
+/******************************************************************************/
+
+static int
+fusion_call_read_proc (char *buf, char **start, off_t offset,
+                       int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          bool        idle = true;
+          FusionCall *call = (FusionCall*) l;
+
+          if (call->executions)
+               idle = ((FusionCallExecution*) call->executions)->executed;
+
+          written += sprintf(buf+written,
+                             "(%5d) 0x%08x (%d calls) %s\n",
+                             call->pid, call->id, call->count,
+                             idle ? "idle" : "executing");
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->call.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_call_init (FusionDev *dev)
+{
+     create_proc_read_entry("calls", 0, dev->proc_dir,
+                            fusion_call_read_proc, dev);
+
+     init_MUTEX(&dev->call.lock);
+
+     return 0;
+}
+
+void
+fusion_call_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     remove_proc_entry ("calls", dev->proc_dir);
+
+     l = dev->call.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          free_all_executions (call);
+
+          kfree (call);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_call_new (FusionDev *dev, int fusion_id, FusionCallNew *call_new)
+{
+     FusionCall *call;
+
+     call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
+     if (!call)
+          return -ENOMEM;
+
+     memset (call, 0, sizeof(FusionCall));
+
+     if (down_interruptible (&dev->call.lock)) {
+          kfree (call);
+          return -EINTR;
+     }
+
+     call->id        = dev->call.ids++;
+     call->pid       = current->pid;
+     call->fusion_id = fusion_id;
+     call->handler   = call_new->handler;
+     call->ctx       = call_new->ctx;
+
+     init_MUTEX (&call->lock);
+
+     fusion_list_prepend (&dev->call.list, &call->link);
+
+     up (&dev->call.lock);
+
+     call_new->call_id = call->id;
+
+     return 0;
+}
+
+int
+fusion_call_execute (FusionDev *dev, int fusion_id, FusionCallExecute *execute)
+{
+     int                  ret;
+     FusionCall          *call;
+     FusionCallExecution *execution;
+     FusionCallMessage    message;
+
+     ret = lock_call (dev, execute->call_id, &call);
+     if (ret)
+          return ret;
+
+     execution = add_execution (call, fusion_id, execute);
+     if (!execution) {
+          unlock_call (call);
+          return -ENOMEM;
+     }
+
+     /* Send call message. */
+     message.handler  = call->handler;
+     message.ctx      = call->ctx;
+
+     message.caller   = fusion_id;
+
+     message.call_arg = execute->call_arg;
+     message.call_ptr = execute->call_ptr;
+
+     ret = fusionee_send_message (dev, fusion_id, call->fusion_id, FMT_CALL,
+                                  call->id, sizeof(message), &message);
+     if (ret) {
+          remove_execution (call, execution);
+          kfree (execution);
+          unlock_call (call);
+          return ret;
+     }
+
+     call->count++;
+
+     if (fusion_id) {
+          /* TODO: implement timeout */
+          fusion_sleep_on (&execution->wait, &call->lock, 0);
+
+          ret = lock_call (dev, execute->call_id, &call);
+          if (ret)
+               return ret == -EINVAL ? -EIDRM : ret;
+
+          if (signal_pending(current)) {
+               execution->caller = 0;
+               unlock_call (call);
+               return -EINTR;
+          }
+
+          execute->ret_val = execution->ret_val;
+
+          remove_execution (call, execution);
+
+          kfree (execution);
+     }
+
+     unlock_call (call);
+
+     return 0;
+}
+
+int
+fusion_call_return (FusionDev *dev, int fusion_id, FusionCallReturn *call_ret)
+{
+     int         ret;
+     FusionLink *l;
+     FusionCall *call;
+
+     ret = lock_call (dev, call_ret->call_id, &call);
+     if (ret)
+          return ret;
+
+     l = call->last;
+     while (l) {
+          FusionCallExecution *execution = (FusionCallExecution*) l;
+
+          if (execution->executed) {
+               l = l->prev;
+               continue;
+          }
+
+          if (execution->caller) {
+               execution->ret_val  = call_ret->val;
+               execution->executed = true;
+
+               wake_up_interruptible_all (&execution->wait);
+          }
+          else {
+               remove_execution (call, execution);
+
+               kfree (execution);
+          }
+
+          unlock_call (call);
+
+          return 0;
+     }
+
+     unlock_call (call);
+
+     return -EIO;
+}
+
+int
+fusion_call_destroy (FusionDev *dev, int fusion_id, int call_id)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, call_id, &call);
+     if (ret)
+          return ret;
+
+     if (call->fusion_id != fusion_id) {
+          up (&dev->call.lock);
+          return -EIO;
+     }
+
+     if (down_interruptible (&call->lock)) {
+          up (&dev->call.lock);
+          return -EINTR;
+     }
+
+     fusion_list_remove (&dev->call.list, &call->link);
+
+     free_all_executions (call);
+
+     up (&dev->call.lock);
+
+     up (&call->lock);
+
+     kfree (call);
+
+     return 0;
+}
+
+void
+fusion_call_destroy_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->call.lock);
+
+     l = dev->call.list;
+
+     while (l) {
+          FusionLink *next = l->next;
+          FusionCall *call = (FusionCall *) l;
+
+          down (&call->lock);
+
+          if (call->fusion_id == fusion_id) {
+               free_all_executions (call);
+
+               fusion_list_remove (&dev->call.list, &call->link);
+
+               up (&call->lock);
+
+               kfree (call);
+          }
+          else
+               up (&call->lock);
+
+          l = next;
+     }
+
+     up (&dev->call.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->call.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->call.list) {
+          FusionCall *call = (FusionCall *) l;
+
+          if (call->id == id) {
+               *ret_call = call;
+               return 0;
+          }
+     }
+
+     up (&dev->call.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_call (FusionDev *dev, int id, FusionCall **ret_call)
+{
+     int         ret;
+     FusionCall *call;
+
+     ret = lookup_call (dev, id, &call);
+     if (ret)
+          return ret;
+
+     if (call) {
+          fusion_list_move_to_front (&dev->call.list, &call->link);
+
+          if (down_interruptible (&call->lock)) {
+               up (&dev->call.lock);
+               return -EINTR;
+          }
+
+          up (&dev->call.lock);
+     }
+
+     *ret_call = call;
+
+     return 0;
+}
+
+static void
+unlock_call (FusionCall *call)
+{
+     up (&call->lock);
+}
+
+static FusionCallExecution *
+add_execution (FusionCall        *call,
+               int                fusion_id,
+               FusionCallExecute *execute)
+{
+     FusionCallExecution *execution;
+
+     /* Allocate execution. */
+     execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
+     if (!execution)
+          return NULL;
+
+     /* Initialize execution. */
+     memset (execution, 0, sizeof(FusionCallExecution));
+
+     execution->caller = fusion_id;
+
+     init_waitqueue_head (&execution->wait);
+
+     /* Add execution. */
+     fusion_list_prepend (&call->executions, &execution->link);
+
+     if (!call->last)
+          call->last = &execution->link;
+
+     return execution;
+}
+
+static void
+remove_execution (FusionCall          *call,
+                  FusionCallExecution *execution)
+{
+     if (call->last == &execution->link)
+          call->last = execution->link.prev;
+
+     fusion_list_remove (&call->executions, &execution->link);
+}
+
+static void
+free_all_executions (FusionCall *call)
+{
+     while (call->last) {
+          FusionCallExecution *execution = (FusionCallExecution *) call->last;
+
+          remove_execution (call, execution);
+
+          wake_up_interruptible_all (&execution->wait);
+
+          kfree (execution);
+     }
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/call.h linux-2.6.12/drivers/char/fusion/call.h
--- linux-2.6.12.orig/drivers/char/fusion/call.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/call.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__CALL_H__
+#define __FUSION__CALL_H__
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+
+/* module init/cleanup */
+
+int  fusion_call_init   (FusionDev *dev);
+void fusion_call_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_call_new     (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallNew     *call);
+
+int fusion_call_execute (FusionDev         *dev,
+                         int                fusion_id, /* zero if call is
+                                                          from Fusion */
+                         FusionCallExecute *execute);
+
+int fusion_call_return  (FusionDev         *dev,
+                         int                fusion_id,
+                         FusionCallReturn  *call_ret);
+
+int fusion_call_destroy (FusionDev         *dev,
+                         int                fusion_id,
+                         int                call_id);
+
+
+/* internal functions */
+
+void fusion_call_destroy_all (FusionDev *dev,
+                              int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/entries.c linux-2.6.12/drivers/char/fusion/entries.c
--- linux-2.6.12.orig/drivers/char/fusion/entries.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/entries.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,417 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/version.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "entries.h"
+
+
+void
+fusion_entries_init( FusionEntries    *entries,
+                     FusionEntryClass *class,
+                     void             *ctx )
+{
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( class != NULL );
+     FUSION_ASSERT( class->object_size >= sizeof(FusionEntry) );
+
+     memset( entries, 0, sizeof(FusionEntries) );
+
+     entries->class = class;
+     entries->ctx   = ctx;
+
+     init_MUTEX( &entries->lock );
+}
+
+void
+fusion_entries_deinit( FusionEntries *entries )
+{
+     FusionLink       *tmp;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     down( &entries->lock );
+
+     fusion_list_foreach_safe (entry, tmp, entries->list) {
+          if (class->Destroy)
+               class->Destroy( entry, entries->ctx );
+
+          kfree( entry );
+     }
+
+     up( &entries->lock );
+}
+
+int
+fusion_entries_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+     FusionEntries    *entries = private;
+     int               written = 0;
+     struct timeval    now;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     if (!class->Print)
+          return -ENOTSUPP;
+
+     if (down_interruptible (&entries->lock))
+          return -EINTR;
+
+     do_gettimeofday( &now );
+
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->last_lock.tv_sec) {
+               int diff = ((now.tv_sec  - entry->last_lock.tv_sec) * 1000 +
+                           (now.tv_usec - entry->last_lock.tv_usec) / 1000);
+
+               if (diff < 1000) {
+                    written += sprintf( buf + written, "%3d  ms  ", diff );
+               }
+               else if (diff < 1000000) {
+                    written += sprintf( buf + written, "%3d.%d s  ",
+                                        diff / 1000, (diff % 1000) / 100 );
+               }
+               else {
+                    diff = ( now.tv_sec  - entry->last_lock.tv_sec +
+                            (now.tv_usec - entry->last_lock.tv_usec) / 1000000);
+
+                    written += sprintf( buf + written, "%3d.%d h  ",
+                                        diff / 3600, (diff % 3600) / 360 );
+               }
+          }
+          else
+               written += sprintf( buf + written, "  -.-    " );
+
+
+          written += sprintf( buf + written, "(%5d) 0x%08x  ", entry->pid, entry->id );
+
+          written += sprintf( buf + written, "%-24s  ", entry->name[0] ? entry->name : "" );
+
+          written += class->Print( entry, entries->ctx, buf + written );
+
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&entries->lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+
+     return (written<0) ? 0 : written;
+}
+
+int
+fusion_entry_create( FusionEntries *entries,
+                     int           *ret_id )
+{
+     int               ret;
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+     FUSION_ASSERT( ret_id != NULL );
+
+     class = entries->class;
+
+     entry = kmalloc( class->object_size, GFP_KERNEL );
+     if (!entry)
+          return -ENOMEM;
+
+     memset( entry, 0, class->object_size );
+
+     if (down_interruptible( &entries->lock )) {
+          kfree( entry );
+          return -EINTR;
+     }
+
+     entry->entries = entries;
+     entry->id      = entries->ids++;
+     entry->pid     = current->pid;
+
+     init_MUTEX( &entry->lock );
+
+     init_waitqueue_head( &entry->wait );
+
+     if (class->Init) {
+          ret = class->Init( entry, entries->ctx );
+          if (ret) {
+               kfree( entry );
+               return ret;
+          }
+     }
+
+     fusion_list_prepend( &entries->list, &entry->link );
+
+     up( &entries->lock );
+
+     *ret_id = entry->id;
+
+     return 0;
+}
+
+int
+fusion_entry_destroy( FusionEntries  *entries,
+                      int             id )
+{
+     FusionEntry      *entry;
+     FusionEntryClass *class;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( entries->class != NULL );
+
+     class = entries->class;
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Remove the entry from the list. */
+     fusion_list_remove( &entries->list, &entry->link );
+
+     /* Wake up any waiting process. */
+     wake_up_interruptible_all( &entry->wait );
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+
+     /* Call the destroy function. */
+     if (class->Destroy)
+          class->Destroy( entry, entries->ctx );
+
+     /* Deallocate the entry. */
+     kfree( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_set_info( FusionEntries         *entries,
+                       const FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( entry->name, FUSION_ENTRY_INFO_NAME_LENGTH, info->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_get_info( FusionEntries   *entries,
+                       FusionEntryInfo *info )
+{
+     int          ret;
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( info != NULL );
+
+     ret = fusion_entry_lock( entries, info->id, &entry );
+     if (ret)
+          return ret;
+
+     snprintf( info->name, FUSION_ENTRY_INFO_NAME_LENGTH, entry->name );
+
+     fusion_entry_unlock( entry );
+
+     return 0;
+}
+
+int
+fusion_entry_lock( FusionEntries  *entries,
+                   int             id,
+                   FusionEntry   **ret_entry )
+{
+     FusionEntry *entry;
+
+     FUSION_ASSERT( entries != NULL );
+     FUSION_ASSERT( ret_entry != NULL );
+
+     /* Lock entries. */
+     if (down_interruptible( &entries->lock ))
+          return -EINTR;
+
+     /* Lookup the entry. */
+     fusion_list_foreach (entry, entries->list) {
+          if (entry->id == id)
+               break;
+     }
+
+     /* Check if no entry was found. */
+     if (!entry) {
+          up( &entries->lock );
+          return -EINVAL;
+     }
+
+     FUSION_ASSUME( entry->lock_pid != current->pid );
+
+     /* Move the entry to the front of all entries. */
+     fusion_list_move_to_front( &entries->list, &entry->link );
+
+     /* Lock the entry. */
+     if (down_interruptible( &entry->lock )) {
+          up( &entries->lock );
+          return -EINTR;
+     }
+
+     /* Mark as locked. */
+     entry->lock_pid = current->pid;
+
+     /* Keep timestamp, but use the slightly
+        inexact version to avoid performance impacts. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) && defined _STRUCT_TIMESPEC
+     entry->last_lock.tv_sec = xtime.tv_sec;
+     entry->last_lock.tv_usec = xtime.tv_nsec / 1000;
+#else
+     entry->last_lock = xtime;
+#endif
+
+     /* Unlock entries. */
+     up( &entries->lock );
+
+     /* Return the locked entry. */
+     *ret_entry = entry;
+
+     return 0;
+}
+
+void
+fusion_entry_unlock( FusionEntry *entry )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     entry->lock_pid = 0;
+
+     /* Unlock the entry. */
+     up( &entry->lock );
+}
+
+int
+fusion_entry_wait( FusionEntry *entry, long *timeout )
+{
+     int            ret;
+     int            id;
+     FusionEntries *entries;
+     FusionEntry   *entry2;
+
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSERT( entry->entries != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     id      = entry->id;
+     entries = entry->entries;
+
+     entry->waiters++;
+
+     fusion_sleep_on( &entry->wait, &entry->lock, timeout );
+
+     entry->waiters--;
+
+     if (timeout && !*timeout)
+          return -ETIMEDOUT;
+
+     if (signal_pending(current))
+          return -EINTR;
+
+     ret = fusion_entry_lock( entries, id, &entry2 );
+     switch (ret) {
+          case -EINVAL:
+               return -EIDRM;
+
+          case 0:
+               if (entry != entry2)
+                    BUG();
+     }
+
+     return ret;
+}
+
+void
+fusion_entry_notify( FusionEntry *entry, bool all )
+{
+     FUSION_ASSERT( entry != NULL );
+     FUSION_ASSUME( entry->lock_pid == current->pid );
+
+     if (!entry->waiters)
+          return;
+
+     if (all)
+          wake_up_interruptible_all( &entry->wait );
+     else
+          wake_up_interruptible( &entry->wait );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/entries.h linux-2.6.12/drivers/char/fusion/entries.h
--- linux-2.6.12.orig/drivers/char/fusion/entries.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/entries.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,174 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__ENTRIES_H__
+#define __FUSION__ENTRIES_H__
+
+#include "types.h"
+#include "list.h"
+
+
+typedef struct __FD_FusionEntry FusionEntry;
+
+
+typedef const struct {
+     int object_size;
+
+     int  (*Init)   ( FusionEntry *entry, void *ctx );
+     void (*Destroy)( FusionEntry *entry, void *ctx );
+     int  (*Print)  ( FusionEntry *entry, void *ctx, char *buf );
+} FusionEntryClass;
+
+
+typedef struct {
+     FusionEntryClass  *class;
+     void              *ctx;
+
+     FusionLink        *list;
+     int                ids;
+     struct semaphore   lock;
+} FusionEntries;
+
+
+struct __FD_FusionEntry {
+     FusionLink         link;
+
+     FusionEntries     *entries;
+
+     int                id;
+     pid_t              pid;
+
+     pid_t              lock_pid;
+
+     struct semaphore   lock;
+     wait_queue_head_t  wait;
+     int                waiters;
+
+     struct timeval     last_lock;
+
+     char               name[FUSION_ENTRY_INFO_NAME_LENGTH];
+};
+
+
+/* Entries Init & DeInit */
+
+void fusion_entries_init  ( FusionEntries    *entries,
+                            FusionEntryClass *class,
+                            void             *ctx );
+
+void fusion_entries_deinit( FusionEntries    *entries );
+
+
+/* '/proc' support */
+
+int  fusion_entries_read_proc( char *buf, char **start, off_t offset,
+                               int len, int *eof, void *private );
+
+
+/* Create & Destroy */
+
+int  fusion_entry_create  ( FusionEntries    *entries,
+                            int              *ret_id );
+
+int  fusion_entry_destroy ( FusionEntries    *entries,
+                            int               id );
+
+
+/* Information */
+
+int  fusion_entry_set_info( FusionEntries          *entries,
+                            const FusionEntryInfo  *info );
+
+int  fusion_entry_get_info( FusionEntries          *entries,
+                            FusionEntryInfo        *info );
+
+
+/* Lock & Unlock */
+
+int  fusion_entry_lock    ( FusionEntries    *entries,
+                            int               id,
+                            FusionEntry     **ret_entry );
+
+void fusion_entry_unlock  ( FusionEntry      *entry );
+
+
+/** Wait & Notify **/
+
+/*
+ * Wait for the entry to be notified with an optional timeout.
+ *
+ * The entry
+ *   (1) has to be locked prior to calling this function.
+ *   (2) is temporarily unlocked while being waited for.
+ *
+ * If this function returns an error, the entry is not locked again!
+ *
+ * Possible errors are:
+ *   -EIDRM      Entry has been removed while being waited for.
+ *   -ETIMEDOUT  Timeout occured.
+ *   -EINTR      A signal has been received.
+ */
+int  fusion_entry_wait    ( FusionEntry      *entry,
+                            long             *timeout );
+
+/*
+ * Wake up one or all processes waiting for the entry to be notified.
+ *
+ * The entry has to be locked prior to calling this function.
+ */
+void fusion_entry_notify  ( FusionEntry      *entry,
+                            bool              all );
+
+
+#define FUSION_ENTRY_CLASS( Type, name, init_func, destroy_func, print_func )   \
+                                                                                \
+     static FusionEntryClass name##_class = {                                   \
+          .object_size = sizeof(Type),                                          \
+          .Init        = init_func,                                             \
+          .Destroy     = destroy_func,                                          \
+          .Print       = print_func                                             \
+     };                                                                         \
+                                                                                \
+     static inline int fusion_##name##_lock( FusionEntries  *entries,           \
+                                             int             id,                \
+                                             Type          **ret_##name )       \
+     {                                                                          \
+          int          ret;                                                     \
+          FusionEntry *entry;                                                   \
+                                                                                \
+          ret = fusion_entry_lock( entries, id, &entry );                       \
+                                                                                \
+          if (!ret)                                                             \
+               *ret_##name = (Type *) entry;                                    \
+                                                                                \
+          return ret;                                                           \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_unlock( Type *name )                    \
+     {                                                                          \
+          fusion_entry_unlock( (FusionEntry*) name );                           \
+     }                                                                          \
+                                                                                \
+     static inline int fusion_##name##_wait( Type *name, long *timeout )        \
+     {                                                                          \
+          return fusion_entry_wait( (FusionEntry*) name, timeout );             \
+     }                                                                          \
+                                                                                \
+     static inline void fusion_##name##_notify( Type *name, bool all )          \
+     {                                                                          \
+          fusion_entry_notify( (FusionEntry*) name, all );                      \
+     }
+
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fifo.c linux-2.6.12/drivers/char/fusion/fifo.c
--- linux-2.6.12.orig/drivers/char/fusion/fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fifo.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "fifo.h"
+
+void
+fusion_fifo_put (FusionFifo *fifo, FusionLink *link)
+{
+     link->prev = fifo->last;
+     link->next = NULL;
+
+     if (fifo->last)
+          fifo->last->next = link;
+     else
+          fifo->first = link;
+
+     fifo->last = link;
+
+     fifo->count++;
+}
+
+FusionLink *
+fusion_fifo_get (FusionFifo *fifo)
+{
+     FusionLink *first = fifo->first;
+
+     if (!first)
+          return NULL;
+
+     fifo->first = first->next;
+
+     if (fifo->last == first)
+          fifo->last = NULL;
+     else
+          fifo->first->prev = NULL;
+
+     fifo->count--;
+
+     return first;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fifo.h linux-2.6.12/drivers/char/fusion/fifo.h
--- linux-2.6.12.orig/drivers/char/fusion/fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fifo.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__FIFO_H__
+#define __FUSION__FIFO_H__
+
+#include "types.h"
+#include "list.h"
+
+typedef struct {
+     FusionLink *first;
+     FusionLink *last;
+
+     int         count;
+} FusionFifo;
+
+void        fusion_fifo_put   (FusionFifo *fifo,
+                               FusionLink *link);
+
+FusionLink *fusion_fifo_get   (FusionFifo *fifo);
+
+int         fusion_fifo_count (FusionFifo *fifo);
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusiondev.c linux-2.6.12/drivers/char/fusion/fusiondev.c
--- linux-2.6.12.orig/drivers/char/fusion/fusiondev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusiondev.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,956 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+#include <linux/device.h>
+#endif
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+#ifndef FUSION_MAJOR
+#define FUSION_MAJOR 252
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Denis Oliver Kropp <dok@directfb.org>");
+
+struct proc_dir_entry *proc_fusion_dir;
+
+#define NUM_MINORS 8
+
+static FusionDev  *fusion_devs[NUM_MINORS] = { 0 };
+static DECLARE_MUTEX(devs_lock);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+static devfs_handle_t devfs_handles[NUM_MINORS];
+static inline unsigned iminor(struct inode *inode)
+{
+        return MINOR(inode->i_rdev);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+static struct class_simple *fusion_class;
+#endif
+
+/******************************************************************************/
+
+void
+fusion_sleep_on(wait_queue_head_t *q, struct semaphore *lock, signed long *timeout)
+{
+     wait_queue_t wait;
+
+     init_waitqueue_entry (&wait, current);
+
+     current->state = TASK_INTERRUPTIBLE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+     spin_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     spin_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     spin_unlock (&q->lock);
+#else
+     write_lock (&q->lock);
+     __add_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+
+     up (lock);
+
+     if (timeout)
+          *timeout = schedule_timeout(*timeout);
+     else
+          schedule();
+
+     write_lock (&q->lock);
+     __remove_wait_queue (q, &wait);
+     write_unlock (&q->lock);
+#endif
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_stat_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+     FusionDev *dev     = private;
+     int        written = 0;
+
+     written += snprintf( buf, len,
+                          "lease/purchase   cede      attach     detach      "
+                          "ref up   ref down  prevail/swoop dismiss\n" );
+     if (written < offset) {
+          offset -= written;
+          written = 0;
+     }
+
+     if (written < len) {
+          written += snprintf( buf+written, len - written,
+                               "%10d %10d  %10d %10d  %10d %10d  %10d %10d\n",
+                               dev->stat.property_lease_purchase,
+                               dev->stat.property_cede,
+                               dev->stat.reactor_attach,
+                               dev->stat.reactor_detach,
+                               dev->stat.ref_up,
+                               dev->stat.ref_down,
+                               dev->stat.skirmish_prevail_swoop,
+                               dev->stat.skirmish_dismiss );
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+     }
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+/******************************************************************************/
+
+static int
+fusiondev_init (FusionDev *dev)
+{
+     int ret;
+
+     ret = fusionee_init (dev);
+     if (ret)
+          goto error_fusionee;
+
+     ret = fusion_ref_init (dev);
+     if (ret)
+          goto error_ref;
+
+     ret = fusion_skirmish_init (dev);
+     if (ret)
+          goto error_skirmish;
+
+     ret = fusion_property_init (dev);
+     if (ret)
+          goto error_property;
+
+     ret = fusion_reactor_init (dev);
+     if (ret)
+          goto error_reactor;
+
+     ret = fusion_call_init (dev);
+     if (ret)
+          goto error_call;
+
+     create_proc_read_entry("stat", 0, dev->proc_dir,
+                            fusiondev_stat_read_proc, dev);
+
+     return 0;
+
+
+error_call:
+     fusion_reactor_deinit (dev);
+
+error_reactor:
+     fusion_property_deinit (dev);
+
+error_property:
+     fusion_skirmish_deinit (dev);
+
+error_skirmish:
+     fusion_ref_deinit (dev);
+
+error_ref:
+     fusionee_deinit (dev);
+
+error_fusionee:
+     return ret;
+}
+
+static void
+fusiondev_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("stat", dev->proc_dir);
+
+     fusion_call_deinit (dev);
+     fusion_reactor_deinit (dev);
+     fusion_property_deinit (dev);
+     fusion_skirmish_deinit (dev);
+     fusion_ref_deinit (dev);
+     fusionee_deinit (dev);
+}
+
+/******************************************************************************/
+
+static int
+fusion_open (struct inode *inode, struct file *file)
+{
+     int ret;
+     int fusion_id;
+     int minor = iminor(inode);
+
+     DEBUG( "fusion_open\n" );
+
+     if (down_interruptible (&devs_lock))
+          return -EINTR;
+
+     if (!fusion_devs[minor]) {
+          char buf[4];
+
+          fusion_devs[minor] = kmalloc (sizeof(FusionDev), GFP_KERNEL);
+          if (!fusion_devs[minor]) {
+               up (&devs_lock);
+               return -ENOMEM;
+          }
+
+          memset (fusion_devs[minor], 0, sizeof(FusionDev));
+
+          snprintf (buf, 4, "%d", minor);
+
+          fusion_devs[minor]->proc_dir = proc_mkdir (buf, proc_fusion_dir);
+
+          ret = fusiondev_init (fusion_devs[minor]);
+          if (ret) {
+               remove_proc_entry (buf, proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+
+               up (&devs_lock);
+
+               return ret;
+          }
+     }
+     else if (file->f_flags & O_EXCL) {
+          up (&devs_lock);
+          return -EBUSY;
+     }
+
+     ret = fusionee_new (fusion_devs[minor], &fusion_id);
+     if (ret) {
+          if (!fusion_devs[minor]->refs) {
+               fusiondev_deinit (fusion_devs[minor]);
+
+               remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                                  proc_fusion_dir);
+
+               kfree (fusion_devs[minor]);
+               fusion_devs[minor] = NULL;
+          }
+
+          up (&devs_lock);
+
+          return ret;
+     }
+
+     fusion_devs[minor]->refs++;
+
+     up (&devs_lock);
+
+
+     file->private_data = (void*) fusion_id;
+
+     return 0;
+}
+
+static int
+fusion_release (struct inode *inode, struct file *file)
+{
+     int ret;
+     int minor     = iminor(inode);
+     int fusion_id = (int) file->private_data;
+
+     DEBUG( "fusion_release\n" );
+
+     ret = fusionee_destroy (fusion_devs[minor], fusion_id);
+     if (ret)
+          return ret;
+
+     down (&devs_lock);
+
+     if (! --fusion_devs[minor]->refs) {
+          fusiondev_deinit (fusion_devs[minor]);
+
+          remove_proc_entry (fusion_devs[minor]->proc_dir->name,
+                             proc_fusion_dir);
+
+          kfree (fusion_devs[minor]);
+          fusion_devs[minor] = NULL;
+     }
+
+     up (&devs_lock);
+
+     return 0;
+}
+
+static int
+fusion_flush (struct file *file)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     (void) fusion_id;
+
+     DEBUG( "fusion_flush (0x%08x %d)\n", fusion_id, current->pid );
+
+     if (current->flags & PF_EXITING)
+          fusion_skirmish_dismiss_all_from_pid (dev, current->pid);
+
+     return 0;
+}
+
+static ssize_t
+fusion_read (struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_read (%d)\n", count );
+
+     return fusionee_get_messages (dev, fusion_id, buf, count,
+                                   !(file->f_flags & O_NONBLOCK));
+}
+
+static unsigned int
+fusion_poll (struct file *file, poll_table * wait)
+{
+     int        fusion_id = (int) file->private_data;
+     FusionDev *dev       = fusion_devs[iminor(file->f_dentry->d_inode)];
+
+     DEBUG( "fusion_poll\n" );
+
+     return fusionee_poll (dev, fusion_id, file, wait);
+}
+
+static int
+lounge_ioctl (FusionDev *dev, int fusion_id,
+              unsigned int cmd, unsigned long arg)
+{
+     int             ret;
+     FusionEnter     enter;
+     FusionKill      kill;
+     FusionEntryInfo info;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_ENTER):
+               if (copy_from_user (&enter, (FusionEnter*) arg, sizeof(enter)))
+                    return -EFAULT;
+
+               if (enter.api.major != FUSION_API_MAJOR || enter.api.minor > FUSION_API_MINOR)
+                    return -ENOPROTOOPT;
+
+               enter.fusion_id = fusion_id;
+
+               if (copy_to_user ((FusionEnter*) arg, &enter, sizeof(enter)))
+                    return -EFAULT;
+
+               return 0;
+
+          case _IOC_NR(FUSION_KILL):
+               if (copy_from_user (&kill, (FusionKill*) arg, sizeof(kill)))
+                    return -EFAULT;
+
+               return fusionee_kill (dev, fusion_id,
+                                     kill.fusion_id, kill.signal, kill.timeout_ms);
+
+          case _IOC_NR(FUSION_ENTRY_SET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         return fusion_entry_set_info (&dev->skirmish, &info);
+
+                    case FT_PROPERTY:
+                         return fusion_entry_set_info (&dev->properties, &info);
+
+                    case FT_REACTOR:
+                         return fusion_entry_set_info (&dev->reactor, &info);
+
+                    default:
+                         return -ENOSYS;
+               }
+
+          case _IOC_NR(FUSION_ENTRY_GET_INFO):
+               if (copy_from_user (&info, (FusionEntryInfo*) arg, sizeof(info)))
+                    return -EFAULT;
+
+               switch (info.type) {
+                    case FT_SKIRMISH:
+                         ret = fusion_entry_get_info (&dev->skirmish, &info);
+                         break;
+
+                    case FT_PROPERTY:
+                         ret = fusion_entry_get_info (&dev->properties, &info);
+                         break;
+
+                    case FT_REACTOR:
+                         ret = fusion_entry_get_info (&dev->reactor, &info);
+                         break;
+
+                    default:
+                         return -ENOSYS;
+               }
+
+               if (ret)
+                    return ret;
+
+               if (copy_to_user ((FusionEntryInfo*) arg, &info, sizeof(info)))
+                    return -EFAULT;
+
+               return 0;
+     }
+
+     return -ENOSYS;
+}
+
+static int
+messaging_ioctl (FusionDev *dev, int fusion_id,
+                 unsigned int cmd, unsigned long arg)
+{
+     FusionSendMessage send;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SEND_MESSAGE):
+               if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
+                    return -EFAULT;
+
+               if (send.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (send.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusionee_send_message (dev, fusion_id, send.fusion_id, FMT_SEND,
+                                             send.msg_id, send.msg_size, send.msg_data);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+call_ioctl (FusionDev *dev, int fusion_id,
+            unsigned int cmd, unsigned long arg)
+{
+     int               id;
+     int               ret;
+     FusionCallNew     call;
+     FusionCallExecute execute;
+     FusionCallReturn  call_ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_CALL_NEW):
+               if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
+                    return -EFAULT;
+
+               ret = fusion_call_new (dev, fusion_id, &call);
+               if (ret)
+                    return ret;
+
+               if (put_user (call.call_id, (int*) arg)) {
+                    fusion_call_destroy (dev, fusion_id, call.call_id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_EXECUTE):
+               if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
+                    return -EFAULT;
+
+               ret = fusion_call_execute (dev, fusion_id, &execute);
+               if (ret)
+                    return ret;
+
+               if (put_user (execute.ret_val, (int*) arg))
+                    return -EFAULT;
+               return 0;
+
+          case _IOC_NR(FUSION_CALL_RETURN):
+               if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
+                    return -EFAULT;
+
+               return fusion_call_return (dev, fusion_id, &call_ret);
+
+          case _IOC_NR(FUSION_CALL_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_call_destroy (dev, fusion_id, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+ref_ioctl (FusionDev *dev, int fusion_id,
+           unsigned int cmd, unsigned long arg)
+{
+     int              id;
+     int              ret;
+     int              refs;
+     FusionRefWatch   watch;
+     FusionRefInherit inherit;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REF_NEW):
+               ret = fusion_ref_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_ref_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REF_UP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UP_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_up (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_DOWN):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_DOWN_GLOBAL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_down (dev, id, 0);
+
+          case _IOC_NR(FUSION_REF_ZERO_LOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_lock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_ZERO_TRYLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_zero_trylock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_UNLOCK):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_unlock (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REF_STAT):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               ret = fusion_ref_stat (dev, id, &refs);
+               if (ret)
+                    return ret;
+
+               return refs;
+
+          case _IOC_NR(FUSION_REF_WATCH):
+               if (copy_from_user (&watch, (FusionRefWatch*) arg, sizeof(watch)))
+                    return -EFAULT;
+
+               return fusion_ref_watch (dev, watch.id, watch.call_id, watch.call_arg);
+
+          case _IOC_NR(FUSION_REF_INHERIT):
+               if (copy_from_user (&inherit, (FusionRefInherit*) arg, sizeof(inherit)))
+                    return -EFAULT;
+
+               return fusion_ref_inherit (dev, inherit.id, inherit.from);
+
+          case _IOC_NR(FUSION_REF_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_ref_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+skirmish_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_SKIRMISH_NEW):
+               ret = fusion_skirmish_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_skirmish_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_SKIRMISH_PREVAIL):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_prevail (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_SWOOP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_swoop (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DISMISS):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_dismiss (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_SKIRMISH_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_skirmish_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+property_ioctl (FusionDev *dev, int fusion_id,
+                unsigned int cmd, unsigned long arg)
+{
+     int id;
+     int ret;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_PROPERTY_NEW):
+               ret = fusion_property_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_property_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_PROPERTY_LEASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_lease (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_PURCHASE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_purchase (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_CEDE):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_cede (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_HOLDUP):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_holdup (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_PROPERTY_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_property_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+reactor_ioctl (FusionDev *dev, int fusion_id,
+               unsigned int cmd, unsigned long arg)
+{
+     int                   id;
+     int                   ret;
+     FusionReactorDispatch dispatch;
+
+     switch (_IOC_NR(cmd)) {
+          case _IOC_NR(FUSION_REACTOR_NEW):
+               ret = fusion_reactor_new (dev, &id);
+               if (ret)
+                    return ret;
+
+               if (put_user (id, (int*) arg)) {
+                    fusion_reactor_destroy (dev, id);
+                    return -EFAULT;
+               }
+               return 0;
+
+          case _IOC_NR(FUSION_REACTOR_ATTACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_attach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DETACH):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_detach (dev, id, fusion_id);
+
+          case _IOC_NR(FUSION_REACTOR_DISPATCH):
+               if (copy_from_user (&dispatch,
+                                   (FusionReactorDispatch*) arg, sizeof(dispatch)))
+                    return -EFAULT;
+
+               if (dispatch.msg_size <= 0)
+                    return -EINVAL;
+
+               /* message data > 64k should be stored in shared memory */
+               if (dispatch.msg_size > 0x10000)
+                    return -EMSGSIZE;
+
+               return fusion_reactor_dispatch (dev, dispatch.reactor_id,
+                                               dispatch.self ? 0 : fusion_id,
+                                               dispatch.msg_size, dispatch.msg_data);
+
+          case _IOC_NR(FUSION_REACTOR_DESTROY):
+               if (get_user (id, (int*) arg))
+                    return -EFAULT;
+
+               return fusion_reactor_destroy (dev, id);
+     }
+
+     return -ENOSYS;
+}
+
+static int
+fusion_ioctl (struct inode *inode, struct file *file,
+              unsigned int cmd, unsigned long arg)
+{
+     int        id  = (int) file->private_data;
+     FusionDev *dev = fusion_devs[iminor(inode)];
+
+     DEBUG( "fusion_ioctl (0x%08x)\n", cmd );
+
+     switch (_IOC_TYPE(cmd)) {
+          case FT_LOUNGE:
+               return lounge_ioctl( dev, id, cmd, arg );
+
+          case FT_MESSAGING:
+               return messaging_ioctl( dev, id, cmd, arg );
+
+          case FT_CALL:
+               return call_ioctl( dev, id, cmd, arg );
+
+          case FT_REF:
+               return ref_ioctl( dev, id, cmd, arg );
+
+          case FT_SKIRMISH:
+               return skirmish_ioctl( dev, id, cmd, arg );
+
+          case FT_PROPERTY:
+               return property_ioctl( dev, id, cmd, arg );
+
+          case FT_REACTOR:
+               return reactor_ioctl( dev, id, cmd, arg );
+     }
+
+     return -ENOSYS;
+}
+
+static struct file_operations fusion_fops = {
+     .owner   = THIS_MODULE,
+     .open    = fusion_open,
+     .flush   = fusion_flush,
+     .release = fusion_release,
+     .read    = fusion_read,
+     .poll    = fusion_poll,
+     .ioctl   = fusion_ioctl
+};
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static int __init
+register_devices(void)
+{
+     int  i;
+
+     if (register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     fusion_class = class_simple_create (THIS_MODULE, "fusion");
+     if (IS_ERR(fusion_class)) {
+          unregister_chrdev (FUSION_MAJOR, "fusion");
+          return PTR_ERR(fusion_class);
+     }
+#endif
+
+     devfs_mk_dir("fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_add (fusion_class,
+                                   MKDEV(FUSION_MAJOR, i),
+                                   NULL, "fusion%d", i);
+#endif
+
+          devfs_mk_cdev (MKDEV(FUSION_MAJOR, i),
+                         S_IFCHR | S_IRUSR | S_IWUSR,
+                         "fusion/%d", i);
+     }
+
+     return 0;
+}
+#else
+static int __init
+register_devices(void)
+{
+     int  i;
+     char buf[16];
+
+     if (devfs_register_chrdev (FUSION_MAJOR, "fusion", &fusion_fops)) {
+          printk (KERN_ERR "fusion: unable to get major %d\n", FUSION_MAJOR);
+          return -EIO;
+     }
+
+     for (i=0; i<NUM_MINORS; i++) {
+          snprintf (buf, 16, "fusion/%d", i);
+
+          devfs_handles[i] = devfs_register (NULL, buf, DEVFS_FL_DEFAULT,
+                                             FUSION_MAJOR, i,
+                                             S_IFCHR | S_IRUSR | S_IWUSR,
+                                             &fusion_fops, NULL);
+     }
+
+     return 0;
+}
+#endif
+
+int __init
+fusion_init(void)
+{
+     int ret;
+
+     ret = register_devices();
+     if (ret)
+          return ret;
+
+     proc_fusion_dir = proc_mkdir ("fusion", NULL);
+
+     return 0;
+}
+
+/******************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+          class_simple_device_remove (MKDEV(FUSION_MAJOR, i));
+#endif
+
+          devfs_remove ("fusion/%d", i);
+     }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 2)
+     class_simple_destroy (fusion_class);
+#endif
+
+     devfs_remove ("fusion");
+}
+#else
+static void __exit
+deregister_devices(void)
+{
+     int i;
+
+     devfs_unregister_chrdev (FUSION_MAJOR, "fusion");
+
+     for (i=0; i<NUM_MINORS; i++)
+          devfs_unregister (devfs_handles[i]);
+}
+#endif
+
+void __exit
+fusion_exit(void)
+{
+     deregister_devices();
+
+     remove_proc_entry ("fusion", NULL);
+}
+
+module_init(fusion_init);
+module_exit(fusion_exit);
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusiondev.h linux-2.6.12/drivers/char/fusion/fusiondev.h
--- linux-2.6.12.orig/drivers/char/fusion/fusiondev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusiondev.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSIONDEV_H__
+#define __FUSIONDEV_H__
+
+#include <linux/proc_fs.h>
+
+#include "entries.h"
+#include "list.h"
+
+#define FUSION_ASSERT(exp)    if (!(exp)) BUG()
+#define FUSION_ASSUME(exp)    if (!(exp)) printk( KERN_ERR "fusiondev: assumption '" #exp "' failed!\n" )
+
+typedef struct {
+     int refs;
+
+     struct proc_dir_entry *proc_dir;
+
+     struct {
+          int property_lease_purchase;
+          int property_cede;
+
+          int reactor_attach;
+          int reactor_detach;
+
+          int ref_up;
+          int ref_down;
+
+          int skirmish_prevail_swoop;
+          int skirmish_dismiss;
+     } stat;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } call;
+
+     struct {
+          int                last_id;
+          FusionLink        *list;
+          struct semaphore   lock;
+          wait_queue_head_t  wait;
+     } fusionee;
+
+     FusionEntries  properties;
+
+     FusionEntries  reactor;
+
+     struct {
+          int                ids;
+          FusionLink        *list;
+          struct semaphore   lock;
+     } ref;
+
+     FusionEntries  skirmish;
+} FusionDev;
+
+/*
+ * Special version of interruptible_sleep_on() that unlocks the mutex
+ * after adding the entry to the queue (just before schedule).
+ */
+void fusion_sleep_on (wait_queue_head_t *q,
+                      struct semaphore  *lock,
+                      signed long       *timeout_ms);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusionee.c linux-2.6.12/drivers/char/fusion/fusionee.c
--- linux-2.6.12.orig/drivers/char/fusion/fusionee.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusionee.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,507 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fifo.h"
+#include "list.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#if 0
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+#else
+#define DEBUG(x...)  do {} while (0)
+#endif
+
+typedef struct {
+     FusionLink        link;
+
+     struct semaphore  lock;
+
+     int               id;
+     int               pid;
+
+     FusionFifo        messages;
+
+     int               rcv_total;  /* Total number of messages received. */
+     int               snd_total;  /* Total number of messages sent. */
+
+     wait_queue_head_t wait;
+} Fusionee;
+
+typedef struct {
+     FusionLink         link;
+
+     FusionMessageType  type;
+     int                id;
+     int                size;
+     void              *data;
+} Message;
+
+/******************************************************************************/
+
+static int  lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static int  lock_fusionee   (FusionDev *dev, int id, Fusionee **ret_fusionee);
+static void unlock_fusionee (Fusionee *fusionee);
+
+/******************************************************************************/
+
+static int
+fusionees_read_proc(char *buf, char **start, off_t offset,
+                    int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee*) l;
+
+          written += sprintf(buf+written, "(%5d) 0x%08x (%4d messages waiting, %7d received, %7d sent)\n",
+                             fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->fusionee.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusionee_init (FusionDev *dev)
+{
+     init_waitqueue_head (&dev->fusionee.wait);
+
+     init_MUTEX (&dev->fusionee.lock);
+
+     create_proc_read_entry("fusionees", 0, dev->proc_dir,
+                            fusionees_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusionee_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->fusionee.lock);
+
+     remove_proc_entry ("fusionees", dev->proc_dir);
+
+     l = dev->fusionee.list;
+     while (l) {
+          FusionLink *next     = l->next;
+          Fusionee   *fusionee = (Fusionee *) l;
+
+          while (fusionee->messages.count) {
+               Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+               kfree (message);
+          }
+
+          kfree (fusionee);
+
+          l = next;
+     }
+
+     up (&dev->fusionee.lock);
+}
+
+/******************************************************************************/
+
+int
+fusionee_new (FusionDev *dev, int *id)
+{
+     Fusionee *fusionee;
+
+     fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
+     if (!fusionee)
+          return -ENOMEM;
+
+     memset (fusionee, 0, sizeof(Fusionee));
+
+     if (down_interruptible (&dev->fusionee.lock)) {
+          kfree (fusionee);
+          return -EINTR;
+     }
+
+     fusionee->id  = ++dev->fusionee.last_id;
+     fusionee->pid = current->pid;
+
+     init_MUTEX (&fusionee->lock);
+
+     init_waitqueue_head (&fusionee->wait);
+
+     fusion_list_prepend (&dev->fusionee.list, &fusionee->link);
+
+     up (&dev->fusionee.lock);
+
+     *id = fusionee->id;
+
+     return 0;
+}
+
+int
+fusionee_send_message (FusionDev *dev, int id, int recipient,
+                       FusionMessageType msg_type, int msg_id,
+                       int msg_size, const void *msg_data)
+{
+     int       ret;
+     Message  *message;
+     Fusionee *sender   = NULL;
+     Fusionee *fusionee;
+
+     DEBUG( "fusionee_send_message (%d -> %d, type %d, id %d, size %d)\n",
+            id, recipient, msg_type, msg_id, msg_size );
+
+     ret = lock_fusionee (dev, recipient, &fusionee);
+     if (ret)
+          return ret;
+
+     if (id) {
+          if (id == recipient) {
+               sender = fusionee;
+          }
+          else {
+               ret = lock_fusionee (dev, id, &sender);
+               if (ret) {
+                    unlock_fusionee (fusionee);
+                    return ret == -EINVAL ? -EIO : ret;
+               }
+          }
+     }
+
+     message = kmalloc (sizeof(Message) + msg_size, GFP_KERNEL);
+     if (!message) {
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -ENOMEM;
+     }
+
+     message->data = message + 1;
+
+     if (msg_type == FMT_CALL)
+          memcpy (message->data, msg_data, msg_size);
+     else if (copy_from_user (message->data, msg_data, msg_size)) {
+          kfree (message);
+          if (sender && sender != fusionee)
+               unlock_fusionee (sender);
+          unlock_fusionee (fusionee);
+          return -EFAULT;
+     }
+
+     message->type = msg_type;
+     message->id   = msg_id;
+     message->size = msg_size;
+
+     fusion_fifo_put (&fusionee->messages, &message->link);
+
+     fusionee->rcv_total++;
+     if (sender)
+          sender->snd_total++;
+
+     wake_up_interruptible_all (&fusionee->wait);
+
+     if (sender && sender != fusionee)
+          unlock_fusionee (sender);
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_get_messages (FusionDev *dev,
+                       int id, void *buf, int buf_size, bool block)
+{
+     int       ret;
+     int       written  = 0;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     while (!fusionee->messages.count) {
+          if (!block) {
+               unlock_fusionee (fusionee);
+               return -EAGAIN;
+          }
+
+          fusion_sleep_on (&fusionee->wait, &fusionee->lock, 0);
+
+          if (signal_pending(current))
+               return -EINTR;
+
+          ret = lock_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+     }
+
+     while (fusionee->messages.count) {
+          FusionReadMessage  header;
+          Message           *message = (Message*) fusionee->messages.first;
+          int                bytes   = message->size + sizeof(header);
+
+          if (bytes > buf_size) {
+               if (!written) {
+                    unlock_fusionee (fusionee);
+                    return -EMSGSIZE;
+               }
+
+               break;
+          }
+
+          header.msg_type = message->type;
+          header.msg_id   = message->id;
+          header.msg_size = message->size;
+
+          if (copy_to_user (buf, &header, sizeof(header)) ||
+              copy_to_user (buf + sizeof(header), message->data, message->size)) {
+               unlock_fusionee (fusionee);
+               return -EFAULT;
+          }
+
+          written  += bytes;
+          buf      += bytes;
+          buf_size -= bytes;
+
+          fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     unlock_fusionee (fusionee);
+
+     return written;
+}
+
+unsigned int
+fusionee_poll (FusionDev *dev, int id, struct file *file, poll_table * wait)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     unlock_fusionee (fusionee);
+
+
+     poll_wait (file, &fusionee->wait, wait);
+
+
+     ret = lock_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (!fusionee)
+          return -EINVAL;
+
+     if (fusionee->messages.count) {
+          unlock_fusionee (fusionee);
+
+          return POLLIN | POLLRDNORM;
+     }
+
+     unlock_fusionee (fusionee);
+
+     return 0;
+}
+
+int
+fusionee_kill (FusionDev *dev, int id, int target, int signal, int timeout_ms)
+{
+     long timeout = -1;
+
+     while (true) {
+          int         ret;
+          FusionLink *l;
+          Fusionee   *fusionee;
+          int         killed   = 0;
+
+          ret = lookup_fusionee (dev, id, &fusionee);
+          if (ret)
+               return ret;
+
+          fusion_list_foreach (l, dev->fusionee.list) {
+               Fusionee *f = (Fusionee*) l;
+
+               if (f->id != id && (!target || target == f->id)) {
+                    kill_proc (f->pid, signal, 0);
+                    killed++;
+               }
+          }
+
+          if (!killed || timeout_ms < 0)
+               break;
+
+          if (timeout_ms) {
+               switch (timeout) {
+                    case 0:  /* timed out */
+                         up (&dev->fusionee.lock);
+                         return -ETIMEDOUT;
+
+                    case -1: /* setup timeout */
+                         timeout = (timeout_ms * HZ + 500) / 1000;
+                         if (!timeout)
+                              timeout = 1;
+
+                         /* fall through */
+
+                    default:
+                         fusion_sleep_on (&dev->fusionee.wait,
+                                          &dev->fusionee.lock, &timeout);
+                         break;
+               }
+          }
+          else
+               fusion_sleep_on (&dev->fusionee.wait, &dev->fusionee.lock, NULL);
+
+          if (signal_pending(current))
+               return -EINTR;
+     }
+
+     up (&dev->fusionee.lock);
+
+     return 0;
+}
+
+int
+fusionee_destroy (FusionDev *dev, int id)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     down (&fusionee->lock);
+
+     fusion_list_remove (&dev->fusionee.list, &fusionee->link);
+
+     wake_up_interruptible_all (&dev->fusionee.wait);
+
+     up (&dev->fusionee.lock);
+
+
+     fusion_call_destroy_all (dev, id);
+     fusion_skirmish_dismiss_all (dev, id);
+     fusion_reactor_detach_all (dev, id);
+     fusion_property_cede_all (dev, id);
+     fusion_ref_clear_all_local (dev, id);
+
+     while (fusionee->messages.count) {
+          Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+     }
+
+     up (&fusionee->lock);
+
+     kfree (fusionee);
+
+     return ret;
+}
+
+/******************************************************************************/
+
+static int
+lookup_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     FusionLink *l;
+
+     if (down_interruptible (&dev->fusionee.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->fusionee.list) {
+          Fusionee *fusionee = (Fusionee *) l;
+
+          if (fusionee->id == id) {
+               *ret_fusionee = fusionee;
+               return 0;
+          }
+     }
+
+     up (&dev->fusionee.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_fusionee (FusionDev *dev, int id, Fusionee **ret_fusionee)
+{
+     int       ret;
+     Fusionee *fusionee;
+
+     ret = lookup_fusionee (dev, id, &fusionee);
+     if (ret)
+          return ret;
+
+     if (fusionee) {
+          fusion_list_move_to_front (&dev->fusionee.list, &fusionee->link);
+
+          if (down_interruptible (&fusionee->lock)) {
+               up (&dev->fusionee.lock);
+               return -EINTR;
+          }
+
+          up (&dev->fusionee.lock);
+     }
+
+     *ret_fusionee = fusionee;
+
+     return 0;
+}
+
+static void
+unlock_fusionee (Fusionee *fusionee)
+{
+     up (&fusionee->lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/fusionee.h linux-2.6.12/drivers/char/fusion/fusionee.h
--- linux-2.6.12.orig/drivers/char/fusion/fusionee.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/fusionee.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSIONEE_H__
+#define __FUSIONEE_H__
+
+#include <linux/poll.h>
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusionee_init   (FusionDev *dev);
+void fusionee_deinit (FusionDev *dev);
+
+
+/* internal functions */
+
+int fusionee_new           (FusionDev         *dev,
+                            int               *id);
+
+int fusionee_send_message  (FusionDev         *dev,
+                            int                id,
+                            int                recipient,
+                            FusionMessageType  msg_type,
+                            int                msg_id,
+                            int                msg_size,
+                            const void        *msg_data);
+
+int fusionee_get_messages  (FusionDev         *dev,
+                            int                id,
+                            void              *buf,
+                            int                buf_size,
+                            bool               block);
+
+unsigned
+int fusionee_poll          (FusionDev         *dev,
+                            int                id,
+                            struct file       *file,
+                            poll_table        *wait);
+
+int fusionee_kill          (FusionDev         *dev,
+                            int                id,
+                            int                target,
+                            int                signal,
+                            int                timeout_ms);
+
+int fusionee_destroy       (FusionDev         *dev,
+                            int                id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/list.c linux-2.6.12/drivers/char/fusion/list.c
--- linux-2.6.12.orig/drivers/char/fusion/list.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/list.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "list.h"
+
+void
+fusion_list_prepend (FusionLink **list, FusionLink *link)
+{
+     link->prev = NULL;
+     link->next = *list;
+
+     if (*list)
+          (*list)->prev = link;
+
+     *list = link;
+}
+
+void
+fusion_list_remove (FusionLink **list, FusionLink *link)
+{
+     if (link->prev)
+          link->prev->next = link->next;
+     else
+          *list = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->next = link->prev = NULL;
+}
+
+void
+fusion_list_move_to_front (FusionLink **list, FusionLink *link)
+{
+     if (*list == link)
+          return;
+
+     link->prev->next = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->prev = NULL;
+     link->next = *list;
+
+     (*list)->prev = link;
+
+     *list = link;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/list.h linux-2.6.12/drivers/char/fusion/list.h
--- linux-2.6.12.orig/drivers/char/fusion/list.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/list.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__LIST_H__
+#define __FUSION__LIST_H__
+
+typedef struct _FusionLink {
+     struct _FusionLink *next;
+     struct _FusionLink *prev;
+} FusionLink;
+
+void fusion_list_prepend       (FusionLink **list, FusionLink *link);
+void fusion_list_remove        (FusionLink **list, FusionLink *link);
+void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
+
+
+#define fusion_list_foreach(elem, list)                     \
+     for (elem = (void*)(list);                             \
+          elem;                                             \
+          elem = (void*)(((FusionLink*)(elem))->next))
+
+#define fusion_list_foreach_safe(elem, temp, list)                                             \
+     for (elem = (void*)(list), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL); \
+          elem;                                                                                \
+          elem = (void*)(temp), temp = ((elem) ? (void*)(((FusionLink*)(elem))->next) : NULL))
+
+#endif /* __FUSION__LIST_H__ */
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/property.c linux-2.6.12/drivers/char/fusion/property.c
--- linux-2.6.12.orig/drivers/char/fusion/property.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/property.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,337 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#ifndef yield
+#define yield schedule
+#endif
+
+#include <linux/fusion.h>
+
+#include "entries.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "property.h"
+
+typedef enum {
+     FUSION_PROPERTY_AVAILABLE = 0,
+     FUSION_PROPERTY_LEASED,
+     FUSION_PROPERTY_PURCHASED
+} FusionPropertyState;
+
+typedef struct {
+     FusionEntry         entry;
+
+     FusionPropertyState state;
+     int                 fusion_id; /* non-zero if leased/purchased */
+     unsigned long       purchase_stamp;
+     int                 lock_pid;
+     int                 count;    /* lock counter */
+} FusionProperty;
+
+static int
+fusion_property_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     FusionProperty *property = (FusionProperty*) entry;
+
+     if (property->state != FUSION_PROPERTY_AVAILABLE) {
+          return sprintf( buf, "%s by 0x%08x (%d) %dx\n",
+                          property->state == FUSION_PROPERTY_LEASED ? "leased" : "purchased",
+                          property->fusion_id, property->lock_pid, property->count );
+     }
+
+     return sprintf( buf, "\n" );
+}
+
+FUSION_ENTRY_CLASS( FusionProperty, property, NULL, NULL, fusion_property_print )
+
+/******************************************************************************/
+
+int
+fusion_property_init( FusionDev *dev )
+{
+     fusion_entries_init( &dev->properties, &property_class, dev );
+
+     create_proc_read_entry( "properties", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->properties );
+
+     return 0;
+}
+
+void
+fusion_property_deinit( FusionDev *dev )
+{
+     remove_proc_entry( "properties", dev->proc_dir );
+
+     fusion_entries_deinit( &dev->properties );
+}
+
+/******************************************************************************/
+
+int
+fusion_property_new( FusionDev *dev, int *ret_id )
+{
+     return fusion_entry_create( &dev->properties, ret_id );
+}
+
+int
+fusion_property_lease( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     long            timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state     = FUSION_PROPERTY_LEASED;
+                    property->fusion_id = fusion_id;
+                    property->lock_pid  = current->pid;
+                    property->count     = 1;
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ / 10) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ / 10;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_purchase( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     signed long     timeout = -1;
+
+     dev->stat.property_lease_purchase++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     while (true) {
+          switch (property->state) {
+               case FUSION_PROPERTY_AVAILABLE:
+                    property->state          = FUSION_PROPERTY_PURCHASED;
+                    property->fusion_id      = fusion_id;
+                    property->purchase_stamp = jiffies;
+                    property->lock_pid       = current->pid;
+                    property->count          = 1;
+
+                    fusion_property_notify( property, true );
+
+                    fusion_property_unlock( property );
+                    return 0;
+
+               case FUSION_PROPERTY_LEASED:
+                    if (property->lock_pid == current->pid) {
+                         fusion_property_unlock( property );
+                         return -EIO;
+                    }
+
+                    ret = fusion_property_wait( property, NULL );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               case FUSION_PROPERTY_PURCHASED:
+                    if (property->lock_pid == current->pid) {
+                         property->count++;
+
+                         fusion_property_unlock( property );
+                         return 0;
+                    }
+
+                    if (timeout == -1) {
+                         if (jiffies - property->purchase_stamp > HZ) {
+                              fusion_property_unlock( property );
+                              return -EAGAIN;
+                         }
+
+                         timeout = HZ;
+                    }
+
+                    ret = fusion_property_wait( property, &timeout );
+                    if (ret)
+                         return ret;
+
+                    break;
+
+               default:
+                    BUG();
+          }
+     }
+
+     BUG();
+
+     /* won't reach this */
+     return -1;
+}
+
+int
+fusion_property_cede( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+     bool            purchased;
+
+     dev->stat.property_cede++;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->lock_pid != current->pid) {
+          fusion_property_unlock( property );
+          return -EIO;
+     }
+
+     if (--property->count) {
+          fusion_property_unlock( property );
+          return 0;
+     }
+
+     purchased = (property->state == FUSION_PROPERTY_PURCHASED);
+
+     property->state     = FUSION_PROPERTY_AVAILABLE;
+     property->fusion_id = 0;
+     property->lock_pid  = 0;
+
+     fusion_property_notify( property, true );
+
+     fusion_property_unlock( property );
+
+     if (purchased)
+          yield();
+
+     return 0;
+}
+
+int
+fusion_property_holdup( FusionDev *dev, int id, int fusion_id )
+{
+     int             ret;
+     FusionProperty *property;
+
+     if (fusion_id > 1)
+          return -EPERM;
+
+     ret = fusion_property_lock( &dev->properties, id, &property );
+     if (ret)
+          return ret;
+
+     if (property->state == FUSION_PROPERTY_PURCHASED) {
+          if (property->fusion_id == fusion_id) {
+               fusion_property_unlock( property );
+               return -EIO;
+          }
+
+          fusionee_kill( dev, fusion_id, property->fusion_id, SIGKILL, -1 );
+     }
+
+     fusion_property_unlock( property );
+
+     return 0;
+}
+
+int
+fusion_property_destroy( FusionDev *dev, int id )
+{
+     return fusion_entry_destroy( &dev->properties, id );
+}
+
+void
+fusion_property_cede_all( FusionDev *dev, int fusion_id )
+{
+     FusionLink *l;
+
+     down( &dev->properties.lock );
+
+     fusion_list_foreach (l, dev->properties.list) {
+          FusionProperty *property = (FusionProperty *) l;
+
+          down( &property->entry.lock );
+
+          if (property->fusion_id == fusion_id) {
+               property->state     = FUSION_PROPERTY_AVAILABLE;
+               property->fusion_id = 0;
+               property->lock_pid  = 0;
+
+               wake_up_interruptible_all (&property->entry.wait);
+          }
+
+          up( &property->entry.lock );
+     }
+
+     up( &dev->properties.lock );
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/property.h linux-2.6.12/drivers/char/fusion/property.h
--- linux-2.6.12.orig/drivers/char/fusion/property.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/property.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__PROPERTY_H__
+#define __FUSION__PROPERTY_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_property_init   (FusionDev *dev);
+void fusion_property_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_property_new      (FusionDev *dev,
+                              int       *ret_id);
+
+int fusion_property_lease    (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_purchase (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_cede     (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_holdup   (FusionDev *dev,
+                              int        id,
+                              int        fusion_id);
+
+int fusion_property_destroy  (FusionDev *dev,
+                              int        id);
+
+
+/* internal functions */
+
+void fusion_property_cede_all (FusionDev *dev,
+                               int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/reactor.c linux-2.6.12/drivers/char/fusion/reactor.c
--- linux-2.6.12.orig/drivers/char/fusion/reactor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/reactor.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,274 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "reactor.h"
+
+typedef struct {
+     FusionLink         link;
+
+     int                fusion_id;
+
+     int                count;     /* number of attach calls */
+} ReactorNode;
+
+typedef struct {
+     FusionEntry        entry;
+
+     FusionLink        *nodes;
+
+     int                dispatch_count;
+} FusionReactor;
+
+/******************************************************************************/
+
+static ReactorNode *get_node      ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         remove_node   ( FusionReactor *reactor,
+                                    int            fusion_id );
+
+static void         free_all_nodes( FusionReactor *reactor );
+
+/******************************************************************************/
+
+static void
+fusion_reactor_destruct( FusionEntry *entry,
+                         void        *ctx )
+{
+     FusionReactor *reactor = (FusionReactor*) entry;
+
+     free_all_nodes( reactor );
+}
+
+static int
+fusion_reactor_print( FusionEntry *entry,
+                      void        *ctx,
+                      char        *buf )
+{
+     int            num     = 0;
+     FusionReactor *reactor = (FusionReactor*) entry;
+     FusionLink    *node    = reactor->nodes;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          num++;
+     }
+
+     return sprintf( buf, "%5dx dispatch, %d nodes\n", reactor->dispatch_count, num );
+}
+
+
+FUSION_ENTRY_CLASS( FusionReactor, reactor, NULL,
+                    fusion_reactor_destruct, fusion_reactor_print )
+
+/******************************************************************************/
+
+int
+fusion_reactor_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->reactor, &reactor_class, dev );
+
+     create_proc_read_entry( "reactors", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->reactor );
+
+     return 0;
+}
+
+void
+fusion_reactor_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("reactors", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->reactor );
+}
+
+/******************************************************************************/
+
+int
+fusion_reactor_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->reactor, ret_id );
+}
+
+int
+fusion_reactor_attach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_attach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
+          if (!node) {
+               fusion_reactor_unlock( reactor );
+               return -ENOMEM;
+          }
+
+          node->fusion_id = fusion_id;
+          node->count     = 1;
+
+          fusion_list_prepend (&reactor->nodes, &node->link);
+     }
+     else
+          node->count++;
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_detach (FusionDev *dev, int id, int fusion_id)
+{
+     int            ret;
+     ReactorNode   *node;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     dev->stat.reactor_detach++;
+
+     node = get_node (reactor, fusion_id);
+     if (!node) {
+          fusion_reactor_unlock( reactor );
+          return -EIO;
+     }
+
+     if (! --node->count) {
+          fusion_list_remove (&reactor->nodes, &node->link);
+          kfree (node);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_dispatch (FusionDev *dev, int id, int fusion_id,
+                         int msg_size, const void *msg_data)
+{
+     int            ret;
+     FusionLink    *l;
+     FusionReactor *reactor;
+
+     ret = fusion_reactor_lock( &dev->reactor, id, &reactor );
+     if (ret)
+          return ret;
+
+     reactor->dispatch_count++;
+
+     fusion_list_foreach (l, reactor->nodes) {
+          ReactorNode *node = (ReactorNode *) l;
+
+          if (node->fusion_id == fusion_id)
+               continue;
+
+          fusionee_send_message (dev, fusion_id, node->fusion_id, FMT_REACTOR,
+                                 reactor->entry.id, msg_size, msg_data);
+     }
+
+     fusion_reactor_unlock( reactor );
+
+     return 0;
+}
+
+int
+fusion_reactor_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->reactor, id );
+}
+
+void
+fusion_reactor_detach_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->reactor.lock);
+
+     fusion_list_foreach (l, dev->reactor.list) {
+          FusionReactor *reactor = (FusionReactor *) l;
+
+          remove_node (reactor, fusion_id);
+     }
+
+     up (&dev->reactor.lock);
+}
+
+/******************************************************************************/
+
+static ReactorNode *
+get_node (FusionReactor *reactor,
+          int            fusion_id)
+{
+     ReactorNode *node;
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id)
+               return node;
+     }
+
+     return NULL;
+}
+
+static void
+remove_node (FusionReactor *reactor, int fusion_id)
+{
+     ReactorNode *node;
+
+     down (&reactor->entry.lock);
+
+     fusion_list_foreach (node, reactor->nodes) {
+          if (node->fusion_id == fusion_id) {
+               fusion_list_remove (&reactor->nodes, &node->link);
+               break;
+          }
+     }
+
+     up (&reactor->entry.lock);
+}
+
+static void
+free_all_nodes (FusionReactor *reactor)
+
+{
+     FusionLink  *n;
+     ReactorNode *node;
+
+     fusion_list_foreach_safe (node, n, reactor->nodes) {
+          kfree (node);
+     }
+
+     reactor->nodes = NULL;
+}
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/reactor.h linux-2.6.12/drivers/char/fusion/reactor.h
--- linux-2.6.12.orig/drivers/char/fusion/reactor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/reactor.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__REACTOR_H__
+#define __FUSION__REACTOR_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_reactor_init   (FusionDev *dev);
+void fusion_reactor_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_reactor_new      (FusionDev  *dev,
+                             int        *id);
+
+int fusion_reactor_attach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_detach   (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id);
+
+int fusion_reactor_dispatch (FusionDev  *dev,
+                             int         id,
+                             int         fusion_id,
+                             int         msg_size,
+                             const void *msg_data);
+
+int fusion_reactor_destroy  (FusionDev  *dev,
+                             int         id);
+
+
+/* internal functions */
+
+void fusion_reactor_detach_all (FusionDev *dev,
+                                int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/ref.c linux-2.6.12/drivers/char/fusion/ref.c
--- linux-2.6.12.orig/drivers/char/fusion/ref.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/ref.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,777 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "list.h"
+#include "call.h"
+#include "ref.h"
+
+typedef struct __Fusion_FusionRef FusionRef;
+
+typedef struct {
+     FusionLink  link;
+     int         fusion_id;
+     int         refs;
+} LocalRef;
+
+typedef struct {
+     FusionLink  link;
+     FusionRef  *ref;
+} Inheritor;
+
+struct __Fusion_FusionRef {
+     FusionLink         link;
+
+     struct semaphore   lock;
+
+     int                id;
+     int                pid;
+
+     int                global;
+     int                local;
+
+     int                locked;    /* non-zero fusion id of lock owner */
+
+     bool               watched;   /* true if watch has been installed */
+     int                call_id;   /* id of call registered with a watch */
+     int                call_arg;  /* optional call parameter */
+
+     FusionRef         *inherited;
+     FusionLink        *inheritors;
+
+     FusionLink        *local_refs;
+
+     wait_queue_head_t  wait;
+};
+
+/******************************************************************************/
+
+static int  lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static int  lock_ref   (FusionDev *dev, bool locked, int id, FusionRef **ret_ref);
+static void unlock_ref (FusionRef *ref);
+
+static int  add_local       (FusionRef *ref, int fusion_id, int add);
+static void clear_local     (FusionDev *dev, FusionRef *ref, int fusion_id);
+static void free_all_local  (FusionRef *ref);
+
+static int  propagate_local (FusionDev *dev, FusionRef *ref, int diff);
+
+static void notify_ref      (FusionDev *dev, FusionRef *ref);
+
+static int  add_inheritor   (FusionRef *ref, FusionRef *from);
+static void remove_inheritor(FusionRef *ref, FusionRef *from);
+static void drop_inheritors (FusionDev *dev, FusionRef *ref);
+
+/******************************************************************************/
+
+static int
+refs_read_proc(char *buf, char **start, off_t offset,
+               int len, int *eof, void *private)
+{
+     FusionLink *l;
+     FusionDev  *dev     = private;
+     int         written = 0;
+
+     if (down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef*) l;
+
+          if (ref->locked)
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d (locked by %d)\n",
+                                  ref->pid, ref->id, ref->global, ref->local,
+                                  ref->locked);
+          else
+               written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d\n",
+                                  ref->pid, ref->id, ref->global, ref->local);
+          if (written < offset) {
+               offset -= written;
+               written = 0;
+          }
+
+          if (written >= len)
+               break;
+     }
+
+     up (&dev->ref.lock);
+
+     *start = buf + offset;
+     written -= offset;
+     if (written > len) {
+          *eof = 0;
+          return len;
+     }
+
+     *eof = 1;
+     return(written<0) ? 0 : written;
+}
+
+int
+fusion_ref_init (FusionDev *dev)
+{
+     init_MUTEX (&dev->ref.lock);
+
+     create_proc_read_entry("refs", 0, dev->proc_dir,
+                            refs_read_proc, dev);
+
+     return 0;
+}
+
+void
+fusion_ref_deinit (FusionDev *dev)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     remove_proc_entry ("refs", dev->proc_dir);
+
+     l = dev->ref.list;
+     while (l) {
+          FusionLink *next = l->next;
+          FusionRef  *ref  = (FusionRef *) l;
+
+          free_all_local (ref);
+
+          kfree (ref);
+
+          l = next;
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+int
+fusion_ref_new (FusionDev *dev, int *id)
+{
+     FusionRef *ref;
+
+     ref = kmalloc (sizeof(FusionRef), GFP_KERNEL);
+     if (!ref)
+          return -ENOMEM;
+
+     memset (ref, 0, sizeof(FusionRef));
+
+     if (down_interruptible (&dev->ref.lock)) {
+          kfree (ref);
+          return -EINTR;
+     }
+
+     ref->id   = dev->ref.ids++;
+     ref->pid  = current->pid;
+
+     init_MUTEX (&ref->lock);
+
+     init_waitqueue_head (&ref->wait);
+
+     fusion_list_prepend (&dev->ref.list, &ref->link);
+
+     up (&dev->ref.lock);
+
+     *id = ref->id;
+
+     return 0;
+}
+
+int
+fusion_ref_up (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_up++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = add_local (ref, fusion_id, 1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, 1 );
+     }
+     else
+          ref->global++;
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_down (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     dev->stat.ref_down++;
+
+     if (ref->locked) {
+          ret = -EAGAIN;
+          goto out;
+     }
+
+     if (fusion_id) {
+          ret = -EIO;
+          if (!ref->local)
+               goto out;
+
+          ret = add_local (ref, fusion_id, -1);
+          if (ret)
+               goto out;
+
+          ret = propagate_local( dev, ref, -1 );
+     }
+     else {
+          if (!ref->global) {
+               ret = -EIO;
+               goto out;
+          }
+
+          ref->global--;
+
+          if (ref->local + ref->global == 0)
+               notify_ref (dev, ref);
+     }
+
+
+out:
+     up (&dev->ref.lock);
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_zero_lock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     while (true) {
+          ret = lock_ref (dev, false, id, &ref);
+          if (ret)
+               return ret;
+
+          if (ref->watched) {
+               unlock_ref (ref);
+               return -EACCES;
+          }
+
+          if (ref->locked) {
+               unlock_ref (ref);
+               return ref->locked == fusion_id ? -EIO : -EAGAIN;
+          }
+
+          if (ref->global || ref->local) {
+               fusion_sleep_on (&ref->wait, &ref->lock, 0);
+
+               if (signal_pending(current))
+                    return -EINTR;
+          }
+          else
+               break;
+     }
+
+     ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_zero_trylock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked) {
+          unlock_ref (ref);
+          return ref->locked == fusion_id ? -EIO : -EAGAIN;
+     }
+
+     if (ref->global || ref->local)
+          ret = -ETOOMANYREFS;
+     else
+          ref->locked = fusion_id;
+
+     unlock_ref (ref);
+
+     return ret;
+}
+
+int
+fusion_ref_unlock (FusionDev *dev, int id, int fusion_id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->locked != fusion_id) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     ref->locked = 0;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_stat (FusionDev *dev, int id, int *refs)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     *refs = ref->global + ref->local;
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_watch (FusionDev      *dev,
+                  int             id,
+                  int             call_id,
+                  int             call_arg)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lock_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref->pid != current->pid) {
+          unlock_ref (ref);
+          return -EACCES;
+     }
+
+     if (ref->global + ref->local == 0) {
+          unlock_ref (ref);
+          return -EIO;
+     }
+
+     if (ref->watched) {
+          unlock_ref (ref);
+          return -EBUSY;
+     }
+
+     ref->watched  = true;
+     ref->call_id  = call_id;
+     ref->call_arg = call_arg;
+
+     wake_up_interruptible_all (&ref->wait);
+
+     unlock_ref (ref);
+
+     return 0;
+}
+
+int
+fusion_ref_inherit (FusionDev *dev,
+                    int        id,
+                    int        from_id)
+{
+     int        ret;
+     FusionRef *ref;
+     FusionRef *from = NULL;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     ret = -EBUSY;
+     if (ref->inherited)
+          goto out;
+
+     ret = lock_ref (dev, true, from_id, &from);
+     if (ret)
+          goto out;
+
+     ret = add_inheritor( ref, from );
+     if (ret)
+          goto out;
+
+     ret = propagate_local( dev, ref, from->local );
+     if (ret)
+          goto out;
+
+     ref->inherited = from;
+
+out:
+     if (from)
+          unlock_ref (from);
+
+     unlock_ref (ref);
+
+     up (&dev->ref.lock);
+
+     return ret;
+}
+
+int
+fusion_ref_destroy (FusionDev *dev, int id)
+{
+     int        ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, false, id, &ref);
+     if (ret)
+          return ret;
+
+     if (down_interruptible (&ref->lock)) {
+          up (&dev->ref.lock);
+          return -EINTR;
+     }
+
+     drop_inheritors( dev, ref );
+
+     if (ref->inherited)
+          remove_inheritor( ref, ref->inherited );
+
+     fusion_list_remove (&dev->ref.list, &ref->link);
+
+     wake_up_interruptible_all (&ref->wait);
+
+     up (&dev->ref.lock);
+
+     free_all_local (ref);
+
+     up (&ref->lock);
+
+     kfree (ref);
+
+     return 0;
+}
+
+void
+fusion_ref_clear_all_local (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->ref.lock);
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          clear_local (dev, ref, fusion_id);
+     }
+
+     up (&dev->ref.lock);
+}
+
+/******************************************************************************/
+
+static int
+lookup_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     FusionLink *l;
+
+     if (!locked && down_interruptible (&dev->ref.lock))
+          return -EINTR;
+
+     fusion_list_foreach (l, dev->ref.list) {
+          FusionRef *ref = (FusionRef *) l;
+
+          if (ref->id == id) {
+               *ret_ref = ref;
+               return 0;
+          }
+     }
+
+     if (!locked)
+          up (&dev->ref.lock);
+
+     return -EINVAL;
+}
+
+static int
+lock_ref (FusionDev *dev, bool locked, int id, FusionRef **ret_ref)
+{
+     int         ret;
+     FusionRef *ref;
+
+     ret = lookup_ref (dev, locked, id, &ref);
+     if (ret)
+          return ret;
+
+     if (ref) {
+          fusion_list_move_to_front (&dev->ref.list, &ref->link);
+
+          if (down_interruptible (&ref->lock)) {
+               if (!locked)
+                    up (&dev->ref.lock);
+               return -EINTR;
+          }
+
+          if (!locked)
+               up (&dev->ref.lock);
+     }
+
+     *ret_ref = ref;
+
+     return 0;
+}
+
+static void
+unlock_ref (FusionRef *ref)
+{
+     up (&ref->lock);
+}
+
+static int
+add_local (FusionRef *ref, int fusion_id, int add)
+{
+     FusionLink *l;
+     LocalRef   *local;
+
+     fusion_list_foreach (l, ref->local_refs) {
+          local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               fusion_list_move_to_front( &ref->local_refs, l );
+
+               if (local->refs + add < 0)
+                    return -EIO;
+
+               local->refs += add;
+               return 0;
+          }
+     }
+
+     local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
+     if (!local)
+          return -ENOMEM;
+
+     local->fusion_id = fusion_id;
+     local->refs      = add;
+
+     fusion_list_prepend (&ref->local_refs, &local->link);
+
+     return 0;
+}
+
+static void
+clear_local (FusionDev *dev, FusionRef *ref, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&ref->lock);
+
+     if (ref->locked == fusion_id) {
+          ref->locked = 0;
+          wake_up_interruptible_all (&ref->wait);
+     }
+
+     fusion_list_foreach (l, ref->local_refs) {
+          LocalRef *local = (LocalRef *) l;
+
+          if (local->fusion_id == fusion_id) {
+               if (local->refs)
+                    propagate_local( dev, ref, - local->refs );
+
+               fusion_list_remove( &ref->local_refs, l );
+
+               kfree (l);
+               break;
+          }
+     }
+
+     up (&ref->lock);
+}
+
+static void
+free_all_local (FusionRef *ref)
+{
+     FusionLink *l = ref->local_refs;
+
+     while (l) {
+          FusionLink *next = l->next;
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->local_refs = NULL;
+}
+
+static void
+notify_ref (FusionDev *dev, FusionRef *ref)
+{
+     if (ref->watched) {
+          FusionCallExecute execute;
+
+          execute.call_id  = ref->call_id;
+          execute.call_arg = ref->call_arg;
+          execute.call_ptr = NULL;
+
+          fusion_call_execute (dev, 0, &execute);
+     }
+     else
+          wake_up_interruptible_all (&ref->wait);
+}
+
+static int
+propagate_local( FusionDev *dev, FusionRef *ref, int diff )
+{
+     FusionLink *l;
+
+     /* Recurse into inheritors. */
+     fusion_list_foreach (l, ref->inheritors) {
+          FusionRef *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: propagate_local() interrupted!\n" );
+               //return -EINTR;
+          }
+
+          propagate_local( dev, inheritor, diff );
+
+          up( &inheritor->lock );
+     }
+
+     /* Apply difference. */
+     ref->local += diff;
+
+     /* Notify zero count. */
+     if (ref->local + ref->global == 0)
+          notify_ref( dev, ref );
+
+     return 0;
+}
+
+static int
+add_inheritor(FusionRef *ref, FusionRef *from)
+{
+     Inheritor *inheritor;
+
+     inheritor = kmalloc (sizeof(Inheritor), GFP_KERNEL);
+     if (!inheritor)
+          return -ENOMEM;
+
+     inheritor->ref = ref;
+
+     fusion_list_prepend( &from->inheritors, &inheritor->link );
+
+     return 0;
+}
+
+static void
+remove_inheritor(FusionRef *ref, FusionRef *from)
+{
+     FusionLink *l;
+
+     down( &from->lock );
+
+     fusion_list_foreach (l, from->inheritors) {
+          Inheritor *inheritor = (Inheritor*) l;
+
+          if (inheritor->ref == ref) {
+               fusion_list_remove( &from->inheritors, &inheritor->link );
+
+               kfree( l );
+               break;
+          }
+     }
+
+     up( &from->lock );
+}
+
+static void
+drop_inheritors( FusionDev *dev, FusionRef *ref )
+{
+     FusionLink *l = ref->inheritors;
+
+     while (l) {
+          FusionLink *next      = l->next;
+          FusionRef  *inheritor = ((Inheritor*) l)->ref;
+
+          if (down_interruptible( &inheritor->lock )) {
+               printk( KERN_ERR "fusion_ref: drop_inheritors() interrupted!\n" );
+               //return;
+          }
+
+          propagate_local( dev, inheritor, - ref->local );
+
+          inheritor->inherited = NULL;
+
+          up( &inheritor->lock );
+
+
+          kfree (l);
+
+          l = next;
+     }
+
+     ref->inheritors = NULL;
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/ref.h linux-2.6.12/drivers/char/fusion/ref.h
--- linux-2.6.12.orig/drivers/char/fusion/ref.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/ref.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__REF_H__
+#define __FUSION__REF_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_ref_init   (FusionDev *dev);
+void fusion_ref_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_ref_new          (FusionDev      *dev,
+                             int            *id);
+
+int fusion_ref_up           (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_down         (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_lock    (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_zero_trylock (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_unlock       (FusionDev      *dev,
+                             int             id,
+                             int             fusion_id);
+
+int fusion_ref_stat         (FusionDev      *dev,
+                             int             id,
+                             int            *refs);
+
+int fusion_ref_watch        (FusionDev      *dev,
+                             int             id,
+                             int             call_id,
+                             int             call_arg);
+
+int fusion_ref_inherit      (FusionDev      *dev,
+                             int             id,
+                             int             from);
+
+int fusion_ref_destroy      (FusionDev      *dev,
+                             int             id);
+
+
+/* internal functions */
+
+void fusion_ref_clear_all_local (FusionDev *dev,
+                                 int        fusion_id);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/skirmish.c linux-2.6.12/drivers/char/fusion/skirmish.c
--- linux-2.6.12.orig/drivers/char/fusion/skirmish.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/skirmish.c	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,246 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "skirmish.h"
+
+
+typedef struct {
+     FusionEntry        entry;
+
+     int                lock_fid;  /* non-zero if locked */
+     int                lock_pid;
+     int                lock_count;
+
+     int                lock_total;
+} FusionSkirmish;
+
+static int
+fusion_skirmish_print( FusionEntry *entry,
+                       void        *ctx,
+                       char        *buf )
+{
+     int             written;
+     FusionSkirmish *skirmish = (FusionSkirmish*) entry;
+
+     written = sprintf( buf, "%6dx total", skirmish->lock_total );
+
+     if (skirmish->lock_fid)
+          return sprintf( buf + written, ", now %dx by 0x%08x (%d)\n",
+                          skirmish->lock_count, skirmish->lock_fid, skirmish->lock_pid) + written;
+
+     return sprintf( buf + written, "\n" ) + written;
+}
+
+FUSION_ENTRY_CLASS( FusionSkirmish, skirmish, NULL, NULL, fusion_skirmish_print )
+
+/******************************************************************************/
+
+int
+fusion_skirmish_init (FusionDev *dev)
+{
+     fusion_entries_init( &dev->skirmish, &skirmish_class, dev );
+
+     create_proc_read_entry( "skirmishs", 0, dev->proc_dir,
+                             fusion_entries_read_proc, &dev->skirmish );
+
+     return 0;
+}
+
+void
+fusion_skirmish_deinit (FusionDev *dev)
+{
+     remove_proc_entry ("skirmishs", dev->proc_dir);
+
+     fusion_entries_deinit( &dev->skirmish );
+}
+
+/******************************************************************************/
+
+int
+fusion_skirmish_new (FusionDev *dev, int *ret_id)
+{
+     return fusion_entry_create( &dev->skirmish, ret_id );
+}
+
+int
+fusion_skirmish_prevail (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     if (skirmish->lock_pid == current->pid) {
+          skirmish->lock_count++;
+          skirmish->lock_total++;
+          fusion_skirmish_unlock( skirmish );
+          return 0;
+     }
+
+     while (skirmish->lock_pid) {
+          ret = fusion_skirmish_wait( skirmish, NULL );
+          if (ret)
+               return ret;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_swoop (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_prevail_swoop++;
+
+     if (skirmish->lock_fid) {
+          if (skirmish->lock_pid == current->pid) {
+               skirmish->lock_count++;
+               skirmish->lock_total++;
+               fusion_skirmish_unlock( skirmish );
+               return 0;
+          }
+
+          fusion_skirmish_unlock( skirmish );
+
+          return -EAGAIN;
+     }
+
+     skirmish->lock_fid   = fusion_id;
+     skirmish->lock_pid   = current->pid;
+     skirmish->lock_count = 1;
+
+     skirmish->lock_total++;
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_dismiss (FusionDev *dev, int id, int fusion_id)
+{
+     int             ret;
+     FusionSkirmish *skirmish;
+
+     ret = fusion_skirmish_lock( &dev->skirmish, id, &skirmish );
+     if (ret)
+          return ret;
+
+     dev->stat.skirmish_dismiss++;
+
+     if (skirmish->lock_pid != current->pid) {
+          fusion_skirmish_unlock( skirmish );
+          return -EIO;
+     }
+
+     if (--skirmish->lock_count == 0) {
+          skirmish->lock_fid = 0;
+          skirmish->lock_pid = 0;
+
+          fusion_skirmish_notify( skirmish, true );
+     }
+
+     fusion_skirmish_unlock( skirmish );
+
+     return 0;
+}
+
+int
+fusion_skirmish_destroy (FusionDev *dev, int id)
+{
+     return fusion_entry_destroy( &dev->skirmish, id );
+}
+
+void
+fusion_skirmish_dismiss_all (FusionDev *dev, int fusion_id)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_fid == fusion_id) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
+void
+fusion_skirmish_dismiss_all_from_pid (FusionDev *dev, int pid)
+{
+     FusionLink *l;
+
+     down (&dev->skirmish.lock);
+
+     fusion_list_foreach (l, dev->skirmish.list) {
+          FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+          down (&skirmish->entry.lock);
+
+          if (skirmish->lock_pid == pid) {
+               skirmish->lock_fid   = 0;
+               skirmish->lock_pid   = 0;
+               skirmish->lock_count = 0;
+
+               wake_up_interruptible_all (&skirmish->entry.wait);
+          }
+
+          up (&skirmish->entry.lock);
+     }
+
+     up (&dev->skirmish.lock);
+}
+
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/skirmish.h linux-2.6.12/drivers/char/fusion/skirmish.h
--- linux-2.6.12.orig/drivers/char/fusion/skirmish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/skirmish.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,57 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002-2003  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__SKIRMISH_H__
+#define __FUSION__SKIRMISH_H__
+
+#include "fusiondev.h"
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_skirmish_init   (FusionDev *dev);
+void fusion_skirmish_deinit (FusionDev *dev);
+
+
+/* public API */
+
+int fusion_skirmish_new     (FusionDev *dev,
+                             int       *id);
+
+int fusion_skirmish_prevail (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_swoop   (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_dismiss (FusionDev *dev,
+                             int        id,
+                             int        fusion_id);
+
+int fusion_skirmish_destroy (FusionDev *dev,
+                             int        id);
+
+
+/* internal functions */
+
+void fusion_skirmish_dismiss_all (FusionDev *dev,
+                                  int        fusion_id);
+
+void fusion_skirmish_dismiss_all_from_pid (FusionDev *dev,
+                                           int        pid);
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/fusion/types.h linux-2.6.12/drivers/char/fusion/types.h
--- linux-2.6.12.orig/drivers/char/fusion/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12/drivers/char/fusion/types.h	2005-06-26 00:17:16.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__TYPES_H__
+#define __FUSION__TYPES_H__
+
+typedef enum {
+  false = 0,
+  true  = !false
+} bool;
+
+#endif
diff -Xxfiles -rNBwdu linux-2.6.12.orig/drivers/char/vt.c linux-2.6.12/drivers/char/vt.c
--- linux-2.6.12.orig/drivers/char/vt.c	2005-06-17 21:48:29.000000000 +0200
+++ linux-2.6.12/drivers/char/vt.c	2005-06-27 11:31:27.000000000 +0200
@@ -158,7 +158,8 @@
 int console_blanked;

 static int vesa_blank_mode; /* 0:none 1:suspendV 2:suspendH 3:powerdown */
-static int blankinterval = 10*60*HZ;
+//static int blankinterval = 10*60*HZ;
+static int blankinterval = 0;
 static int vesa_off_interval;

 static DECLARE_WORK(console_work, console_callback, NULL);
